#!/bin/bash
#---------------------------------------
# yb | yaml bash parser
#---------------------------------------

# Set the eu flag
set -eu

########################################
# Declare globals
# Attributes:
#   $@ # script user options
########################################
_globals(){
  declare -g yb_spacing=2
  declare -g yb_grey="\033[0;30m"
  declare -g yb_blue="\033[1;36m"
  declare -g yb_orange="\033[1;33m"
  declare -g yb_red="\033[31m"
  declare -g yb_add=false
  declare -g yb_remove=false
  declare -g yb_query=false
  declare -g yb_boolean_query=false
  declare -g yb_value_query=false
  declare -g yb_line_number_query=false
  declare -g yb_silent_query=false
  declare -g yb_depth=false
  declare -g yb_format=false
  declare -g yb_is_array=false
  declare -g yb_is_raw=false
  declare -g yb_show_level=false
  declare -g yb_show_line=false
  declare -g yb_show_line_number=false
  declare -g yb_is_sequence=false
  declare -g yb_is_empty=true
  declare -g yb_retrieve=false
  declare -g yb_is_retrieved=false
  declare -g yb_is_print=false
  declare -g yb_one_line=false
  declare -g yb_is_colored=false
  declare -g yb_has_key=false
  declare -g yb_sequence_retrieved=0
  declare -g yb_key_length=0
  declare -g yb_key_step=0
  declare -g yb_key_base_level=0
  declare -g yb_added_lines=0
  declare -g yb_previous_parent=""
  declare -g yb_value=""
  declare -g yb_key_option=""
  declare -g yb_value_option=""
  declare -g yb_YAML=""
  declare -g yb_trimmed=""
  declare -g yb_spacer=""
  declare -g yb_anchor=""
  declare -g yb_color_string=""
  declare -g yb_query_search_result=""
  declare -g yb_query_lines_result=""
  declare -g yb_query_search_values_result=""
  declare -ga yb_coordinates
  declare -ga yb_query_result
  declare -ga yb_array
  declare -gA yb_keys
}

########################################
# Parse a yaml file
# Globals:
#   yb_YAML
########################################
_parse_yaml() {
  local comment
  local yaml
  local separator
  local line
  local spaces
  local level
  local type
  local key=""
  local value=""
  local parent=""
  local line_number=0
  local prefix
  local suffix

  # global associative array
  declare -A line_structure

  # Set whitespace as field separator
  IFS=$' \t\n'

  # Loop through each line of the YAML file
  while IFS= read -r line; do
    # keep track of current line number
    ((line_number += 1))

    # reset variables values
    key=""
    value=""
    suffix=""
    prefix=""
    yb_trimmed=""

    # Count the leading spaces to determine the indentation level
    spaces="${line%%[^[:space:]]*}"
    level="${#spaces}"
    level="$(( level / yb_spacing ))"

    # Remove the leading and trailing spaces
    # line=$(_trim_space "${line}")
    _trim_space "${line}"
    line="${yb_trimmed}"

    # Check the line type
    if [[ -z "${line}" ]]; then 
      type="empty"
    elif [[ "${line}" == "#"* ]]; then
      type="comment"
      value="${line}"
    elif [[ "${line}" == *":" && "${line}" != "-"*":"* ]]; then
      type="key"
      key="${line%%:*}"
      parent="${key}"
      yb_previous_parent="${key}"
      suffix=": "
    elif [[ "${line}" == *": "* && ${line} != "- "* ]]; then
      type="key:value"
      key="${line%%:*}"
      value="${line#*:}"
      # key=$(_trim_space "${key}")
      _trim_space "${key}"
      key="${yb_trimmed}"
      _trim_space "${value}"
      value="${yb_trimmed}"
      parent="${key}"
      suffix=": "
    elif [[ "${line}" == "- "*": "* && "${line}" != *"::"* ]]; then
      type="list-key:value"
      # key=$(_trim_space "${line}")
      _trim_space "${line}"
      _trim_hyphen "${yb_trimmed}"
      key="${yb_trimmed}"
      key="${key%%:*}"
      value="${line#*:}"
      _trim_space "${value}"
      value="${yb_trimmed}"
      prefix="- "
      suffix=": "
      # in this case, the parent is on the previous line
      parent="${yb_previous_parent}"
    elif [[ "${line}" == "-"*":"  && "${line}" != *"::"* ]]; then
      # if [[ ${level} -eq 0 ]]; then
        type="list-key"
        # Trim leading space and list hyphen
        _trim_space "${line}"
        _trim_hyphen "${yb_trimmed}"
        key="${yb_trimmed}"
        key="${key%%:*}"
        prefix="- "
        parent="${key}"
        yb_previous_parent="${key}"
      elif [[ "${line}" == "-"* ]]; then
        type="list-value"
        # Trim leading space and list hyphen
        _trim_space "${line}"
        _trim_hyphen "${yb_trimmed}"
        value="${yb_trimmed}"
        prefix="- "
    else
      type="other"
      value="${line}"
    fi

    # populate the array
    line_structure=(
      [type]="${type}"
      [level]="${level}"
      [line_number]="${line_number}"
      [key]="${key-}"
      [value]="${value-}"
      [parent]="${parent-}"
      [prefix]="${prefix-}"
      [suffix]="${suffix-}"
    )

    # send the reference
    _manage line_structure

  done <<< "${yb_YAML}"

  # reset IFS to default value
  unset IFS
}

########################################
# Manage lines structures depending on action
# Inherit:
#   ${line_structure[@]}
########################################
_manage(){
  local level="${line_structure["level"]}"
  local line_number="${line_structure["line_number"]}"
  local type="${line_structure["type"]}"
  local parent="${line_structure["parent"]}"
  local key="${line_structure["key"]}"
  local prefix="${line_structure["prefix"]}"

  local query_prefix="L${level}_N${line_number}"

  # build $spacer and $outer
  _build_spacer "${level}" "${type}" "${parent}"
  _build_outer "${level}" "${line_number}"

  # assign the structure variables with the global ones
  line_structure["spacer"]="${yb_spacer}"
  line_structure["outer"]="${yb_outer}"

  # if a sequence, search if the path is correct
  if [[ "${yb_is_sequence}" == true ]]; then
     _search "${key}" "${level}" "${type}" "${prefix}" "${query_prefix}"
    # if correct path, print
    if [[ "${yb_is_print}" == true ]]; then
      _print
    fi
  fi
  # if regular print, print
  if [[ "${yb_is_sequence}" == false ]]; then
    _print
  fi
}

########################################
# Search the correct key path
# Attributes:
#   $1 # current $key
#   $2 # current $level
#   $3 # current $type
#   $4 # prefix for -q option
########################################
_search(){
  local key="${1-}"
  local level="${2-}"
  local type="${3-}"
  local prefix="${4-}"
  local query_prefix="${5-}"
  local new_level
  yb_is_print=false

  new_level="${yb_key_step}"

  # if the current level is lower than the expected one, reset
  if [[ "${level}" -lt "${new_level}" ]]; then
    yb_key_step=0
    yb_retrieve=false 
    new_level="${yb_key_step}"
  fi

  if [[ "${yb_retrieve}" == false ]]; then
    # the key and the level are the expected ones, first key is at the root level (0)
    if [[ "${prefix}${key}" == "${yb_keys[${yb_key_step}]}" && "${level}" -eq "${new_level}" ]]; then
      # set new index
      yb_key_step=$(( $yb_key_step + 1))
      # if enough arguments
      if [[ "${yb_key_step}" -eq "${yb_key_length}" ]]; then
        if [[ "${yb_line_number_query}" == true ]]; then
          # if looking for the key coordinates
          yb_query_lines_result+=("${query_prefix}")
        fi
        if [[ "${yb_boolean_query}" == true ]]; then
          # if looking for the key existence confirm and exit
          yb_query_result=true
          if [[ "${yb_add}" == false ]]; then
            # if not in an addition scenario
            echo ${yb_query_result}
          fi
        fi

        yb_retrieve=true
        yb_key_base_level="${level}"
        # assume the key exist
        yb_has_key=true

        # if searched value is *key:value, retrieve only once
        if [[ "${type}" == *"key:value" ]]; then
          # search result is only one line
          yb_one_line=true
          # sequence is over, reset flags
          yb_key_step=0
          yb_retrieve=false
          # send a true signal to print the current line
          yb_is_print=true
          # add one to the number of retrieved sequences
          yb_sequence_retrieved=$(( yb_sequence_retrieved + 1 ))
          # assume the value was filled once
          yb_is_empty=false
          return 0
        fi
      fi
    fi
  elif [[ "${yb_retrieve}" == true && "${level}" -gt "${yb_key_base_level}" ]]; then
    # if search parameters match with current line
    # send a true signal to print the current line
    yb_one_line=false
    yb_is_print=true
    # assume the value was filled once
    yb_is_empty=false
  else
    # if not
    yb_one_line=false
    yb_is_print=false
    # if the level is lower or equal the key level
    # sequence is over, reset flags
    yb_key_step=0
    # yb_is_retrieved=false
    yb_retrieve=false
    # add one to the number of retrieved sequences
    yb_sequence_retrieved=$(( yb_sequence_retrieved + 1 ))
  fi
}

########################################
# Print to terminal
# Inherit:
#   ${line_structure[@]}
########################################
_print(){
  local level=${line_structure["level"]}
  local type="${line_structure["type"]}"
  local key="${line_structure["key"]}"
  local value="${line_structure["value"]}"
  local prefix="${line_structure["prefix"]}"
  local suffix="${line_structure["suffix"]}"
  local line_number="${line_structure["line_number"]}"
  local spacer="${line_structure["spacer"]}"
  local outer="${line_structure["outer"]}"
  local string=""
  local has_colors=""
  yb_is_colored=false
  yb_value=""

  # if a line-number query
  if [[ "${yb_line_number_query}" == true || "${yb_boolean_query}" == true ]]; then
    return 0
  fi

  # if a value query
  if [[ "${yb_value_query}" == true ]]; then
    # if value is the same as the searched option
    if [[ "${yb_value_option}" == "${value}" || "${yb_value_option}" == "- ${value}" ]]; then
      if [[ "${yb_show_line}" == true ]]; then
        yb_query_result="true{{T_${type}}}{{N_${line_number}}}"
      else
        yb_query_result=true
      fi
      if [[ "${yb_silent_query}" == false ]]; then
        echo ${yb_query_result}
      fi
    fi
    return 0
  fi

  if [[ "${yb_is_array}" == true ]]; then
    if [[ "${type}" != "comment" && "${type}" != "empty" ]]; then
      if [[ "${type}" == *"key"* ]]; then
        if [[ "${type}" == "list-key:value" ]]; then
          if [[ "${yb_one_line}" == false ]]; then
            yb_array+=("${spacer}${key}_ ${value}${outer}")
          else
            yb_array+=("${spacer}${value}${outer}")
          fi
        else
          if [[ "${yb_one_line}" == false ]]; then
            yb_array+=("${spacer}${key}_${value}${outer}")
          else
            yb_array+=("${spacer}${value}${outer}")
          fi
        fi
      else
        yb_array+=("${spacer}${value}${outer}")
      fi
    fi
  else
    # if '-R' is false, use colors
    if [[ "${yb_is_raw}" == false ]] && [[ "${yb_format}" == false ]]; then
      if [[ "${type}" == "comment" ]]; then
        _set_color "${value}" "${yb_grey}"
        value="${yb_color_string}"
      elif [[ "${line_structure["type"]}" == *"key"* ]]; then
        _set_color "${key}" "${yb_blue}"
        key="${yb_color_string}"
        _set_color "${prefix}" "${yb_blue}"
        prefix="${yb_color_string}"
      fi
      if [[ "${line_structure["type"]}" == *"value"* ]]; then
        _value_type "${value}"
        if [[ -n "${yb_value}" ]]; then
          value="${yb_value}"
        fi
      fi
    fi

    if [[ "${yb_is_sequence}" == true && "${yb_one_line}" == true ]]; then
      if [[ "${type}" == *"key:value" ]]; then
        if [[ "${yb_is_colored}" == true ]]; then
          echo -e "${value}${outer}"
        else
          echo "${value}${outer}"
        fi
        yb_one_line=false
        yb_is_print=false
      fi
    else
      if [[ "${type}" == "comment" ]]; then
        string=$(echo -e "${prefix}${value}${outer}")
        echo "${spacer}"${string}
      else
        if [[ ${yb_is_colored} == true ]]; then
         string=$(echo -e "${prefix}${key}${suffix}${value}${outer}")
        else
         string=$(echo -e "${prefix}${key}${suffix}" && echo "${value}${outer}")
        fi
        echo "${spacer}"${string}
      fi
    fi
  fi
}

########################################
# Print a debug message
# Attributes:
#   $@ # some message
########################################
_debug(){
  local message="${@}"
  echo "${BASH_LINENO} : ${message}"
}

########################################
# Transform original key option into an array
# Attributes:
#   $1 # a yaml key
# Globals:
#   yb_key_option
#   yb_key_length
# Output:
#   yb_keys[@]
########################################
_key_to_array(){
  local keys="${1:-"${yb_key_option}"}"
  local local_index
  declare -a local_array
  yb_keys=()

  # replace space with anti-backslash
  keys="${keys// /\\}"
  # replace points with spaces
  keys="${keys//./ }"
  # transform the string in an array
  keys=(${keys})

  yb_key_length="${#keys[@]}"

  for (( yk = 0; yk < $yb_key_length; yk++ )); do
    key="${keys[$yk]}"
      if [[ "${key}" == *\\* ]]; then
        # replace anti-backslash with space
        key="${key//\\/ }"
      fi
      yb_keys[$yk]="${key}"
  done
}

########################################
# Query file for an existing key
# Attributes:
#   $1 # mode (boolean verbose)
#   $2 # a key
# Globals:
#   yb_boolean_query
#   yb_line_number_query
#   yb_file
#   yb_is_empty
#   yb_query
#   yb_query_result
########################################
_query_search(){
  
  declare -a key=("${1-}")
  local result
  yb_key_step=0
  yb_query_search_result=""
  yb_query_result=""

  # set the query mode
  yb_boolean_query=true

  # prepare the search sequence and parse file
  _search_sequence "${key[@]}"
  _parse_yaml "${yb_file}"

  # if result contains true and not an addition scenario
  if [[  "${yb_query_result}" == *"true"* && "${yb_add}" == "false" ]]; then
    # output has been returned, exit
    exit 0
  fi

  # get the result
  result="${yb_query_search_result}"

  if [[ -n "${result}" ]]; then
    # has result
    yb_query_result=true
  elif [[ "${yb_is_empty}" == false ]]; then
    # has result but empty one
    if [[ -n "${yb_value_option}" ]]; then
      yb_query_result=false
    else
      yb_query_result=true
    fi
  elif [[ "${result}" == "" ]]; then
    yb_query_result=false
  else
    # no result
    yb_query_result=false
  fi

  # reset flag
  yb_boolean_query=false
}

########################################
# Query file for an existing value
# Attributes:
#   $1 # a key
# Globals:
#   yb_key_step
#   yb_query_search_result
#   yb_query_result
#   yb_value_query
#   yb_file
########################################
_query_search_values(){
  declare -a key=(${@-})
  local result
  yb_key_step=0
  yb_query_result=""

  # set the query mode
  yb_value_query=true

  # prepare the search sequence and parse file
  _search_sequence "${key[@]}"
  _parse_yaml "${yb_file}"

  # if no results are found
  if [[ -z "${yb_query_result}" ]]; then
    yb_query_result=false
  fi

  # reset the query mode
  yb_value_query=false
}

########################################
# Query file for an existing key
# Attributes:
#   $1 # mode (boolean verbose)
#   $2 # a key
# Globals:
#   yb_boolean_query
#   yb_line_number_query
#   yb_file
#   yb_is_empty
#   yb_query
#   yb_query_result
########################################
_query_keys_lines(){
  # local mode="${1-}"
  declare -a key=("${1-}")
  local result
  # empty global array before retrieving results
  yb_query_lines_result=()
  yb_query_result=()
  yb_key_step=0

  # set mode flag
  yb_line_number_query=true

  # prepare the search sequence
  _search_sequence "${key[@]}"
  _parse_yaml "${yb_file}"

  # get the result
  result="${yb_query_lines_result[@]}"
  yb_query_result="${result[@]}"

  # reset flag
  yb_line_number_query=false
}

########################################
# Query file for values coordinates
# Attributes:
#   $1 # a key
# Globals:
#   yb_boolean_query
#   yb_line_number_query
#   yb_file
#   yb_is_empty
#   yb_query
#   yb_query_result
########################################
_query_values_lines(){
  # local mode="${1-}"
  declare -a key=("${1-}")
  local result
  # empty global array before retrieving results
  yb_query_search_values_result=()
  yb_query_result=()
  yb_key_step=0

  # set mode flag
  yb_is_array=true
  yb_show_line_number=true
  yb_search_values_query=true

  # prepare the search sequence
  _search_sequence "${key[@]}"
  _parse_yaml "${yb_file}"

  # get the result
  result="${yb_array[@]}"
  yb_query_result="${result[@]}"

  # reset flag
  yb_is_array=false
}

#########################################
# # Add path child keys
# # Attributes:
# #   $@ # an array of key coordinates (level, line number)
# ########################################
_add_child_keys(){
    declare -a keys_anchors=(${@})
    local parent_level
    local parent_line

    for anchor in "${keys_anchors[@]}"; do
      parent_level="${anchor%%_N*}"
      parent_level="${parent_level#*L}"
      parent_line="${anchor#*N}"

      _add_keys_in_file "${parent_line}" "${parent_level}"
    done
}

########################################
# Add key(s) in a file
# Attributes:
#   $1 # line number
#   $2 # level
#   $3 # index
# Globals:
#   yb_key
#   yb_key_length
########################################
_add_keys_in_file(){
  local parent_line_number="${1-}"
  local parent_level="${2-}"
  local spacing="\ \ "
  local spacer
  local target_line_number
  local counter=0

  # find the correct line depending on previous additions
  target_line_number=$(( $parent_line_number + $yb_added_lines ))

  # referesh keys referential
  _key_to_array "${yb_key_option}"

  for (( aif = $parent_level + 1; aif < $yb_key_length; aif++ )); do 
    spacer=""
    for (( sp = 0; sp < $parent_level + 1; sp++ )); do
      spacer+="${spacing}"
    done

    child_key="${spacer}${yb_keys[${aif}]}:"

    # write in file
    sed -i "${target_line_number} a ${child_key}" "${yb_file}"
    # increment levels and line numbers for next iteration
    parent_level=$(( $parent_level + 1 ))
    target_line_number=$(( $target_line_number + 1 ))
    # increment the global added lines
    counter=$(( $counter + 1 ))
  done
  yb_added_lines=$(( $yb_added_lines + $counter ))
}

########################################
# Add new key(s) in a file
# Globals:
#   yb_key
#   yb_key_length
########################################
_add_new_keys_in_file(){
  local level=0
  local spacing="  "
  local spacer
  # local target_line_number
  local counter=0

  # referesh keys referential
  _key_to_array "${yb_key_option}"

  for (( aif = 0 ; aif < $yb_key_length; aif++ )); do 
    spacer=""
    for (( sp = 0; sp < level; sp++ )); do
      spacer+="${spacing}"
    done

    child_key="${spacer}${yb_keys[${aif}]}:"

    # write in file on the last line
    sed -i "\$s/\$/ \n$child_key/" "${yb_file}"
    # increment levels and line numbers for next iteration
    level=$(( $level + 1 ))
  done
}

########################################
# Build the key coordinates
# Globals:
#   yb_key
#   yb_key_length
#   yb_coordinates
########################################
_manage_keys_addition(){
  local has_key
  declare -a coordinates
  declare -a keys=("${yb_keys[@]}")
  local sequence_length="${yb_key_length}"
  local search_key=""

  local counter=$sequence_length  

  reverse_array=()
  for (( r = ${#keys[@]} - 1; r >= 0; r-- )); do
      reverse_array+=("${keys[r]}")
  done  

  for (( s = 0; s < $sequence_length; s++ )); do
    search_key="" 

    for (( rs = 0; rs < $counter; rs++ )); do
      search_key+=".${reverse_array[$rs]}"
    done  

    # strip first character (a ".")
    search_key="${search_key:1}"
    _query_keys_lines "${search_key}"
    # get result
    has_key=("${yb_query_result}")  

    # this gives a behavior where only 
    # the first level of parents are targeted
    if [[ -n "${has_key}" ]]; then
      break;
    fi

    counter=$(( $counter - 1 ))
  done

  if [[ -z "${has_key}" ]]; then
    _add_new_keys_in_file


  else
    _add_child_keys "${has_key}"
  fi
}

########################################
# Add key(s) in a file
# Attributes:
#   $1 # line number
#   $2 # level
#   $3 # index
# Globals:
#   yb_key
#   yb_key_length
########################################
_add_value_in_file(){
  declare -a parents=(${1-})
  local spacing="\ \ "
  local spacer
  local target_line_number
  local counter=0
  local existing_line
  local value_type
  local key_line
  local key_level
  local parent_key_value
  local inline_value
  declare -a value_array
  declare -a clean_value_array

  # set mode
  if [[ "${yb_value_option}" == "- "* ]]; then
    value_type="list"
  else 
    value_type="inline"
  fi

  if [[ "${value_type}" == "inline" ]]; then
    # iterate over parent keys
    for key in "${parents[@]}"; do
      key_line="${key##*_N}"
      # get the existing content from the line
      parent_key_value=$(sed -n "${key_line}p" "$yb_file")
      # prepare line value
      # todo : explore use of echo here
      inline_value=$(echo "${parent_key_value} ${yb_value_option}")
      # write key:value on the same line
      sed -i "${key_line}c\\$inline_value" "$yb_file"
    done

  elif [[ "${value_type}" == "list" ]]; then

    # add a space before the string to cope with delimeter
    yb_value_option=" ${yb_value_option}"

    # declare parsing values
    string="${yb_value_option}"
    delimiter=' - '
    condition=$string$delimiter

    # check for delimeter in string
    while [[ $condition ]]; do
        value_array+=( "${condition%%"$delimiter"*}" );
        condition=${condition#*"$delimiter"};
    done;

    # iterate over values to clean them
    for raw_value in "${value_array[@]}"; do
      if [[ -n "${raw_value}" ]]; then
        _trim_space ${raw_value}
        raw_value="${yb_trimmed//\\/\\\\}"
        clean_value_array+=("${raw_value}")
      fi
    done

    # iterate over parent keys
    for key in "${parents[@]}"; do
      key_line="${key##*_N}"
      key_level="${key%%_N*}"
      key_level="${key_level##L}"

      # build spacer
      spacer=""
      for (( sp = 0; sp < $key_level + 1; sp++ )); do
        spacer+="${spacing}"
      done

      local clean_array_length=${#clean_value_array[@]}

      for (( cv = clean_array_length - 1; cv >= 0 ; cv-- )); do
        clean_value="${spacer}- ${clean_value_array[$cv]}"
        sed -i "${key_line} a ${clean_value}" "${yb_file}"
      done
    done
  fi
}

########################################
# Manage value addition
# Globals:
#   yb_key
#   yb_key_length
#   yb_coordinates
########################################
_manage_value_addition(){
  local has_key
  declare -a keys=("${yb_keys[@]}")
  local sequence_length="${yb_key_length}"
  local search_key=""

  local counter=$sequence_length  

  # query for lines coordinates
  _query_keys_lines "${search_key}"
  # get result
  has_key=("${yb_query_result}")

  _add_value_in_file "${has_key}"
}

########################################
# Add key(s) and/or value(s)
# Globals:
#   yb_key
#   yb_query
########################################
_add(){
  _query_search "${yb_key_option}"

  if [[ "${yb_query}" == false ]]; then
    _manage_keys_addition "${yb_key_option}"
    _cache_yaml
  fi

  if [[ -n "${yb_value_option-}" ]]; then
    _manage_value_addition "${yb_value_option}"
  fi

  # as sed tends to add trailing whitespaces remove them
  sed -i 's/[[:space:]]*$//'  "${yb_file}"
}

########################################
# Remove key(s) and/or value(s)
# Globals:
#   yb_key_option
#   yb_query_result
#   yb_file
########################################
_remove(){
  declare -a parent_lines=()
  declare -a child_lines=()

  yb_query_result=()
  declare -a child_array
  declare -a remove_lines
  local next_line
  local remove_line
  local line_counter=0

  # get lines for parents and children
  _query_keys_lines "${yb_key_option}"
  parent_lines=(${yb_query_result})
  _query_values_lines "${yb_key_option}"
  child_lines=(${yb_query_result})

  if [[ -z "${parent_lines[@]}" && -z "${child_lines[@]}" ]]; then
    # nothing to remove
    return 0
  fi

  # prepare child lines numbers
  if [[ -n "${child_lines[@]}" ]]; then
    for child in "${child_lines[@]}"; do
      child="${child##*'{{'}"
      child="${child%%'}}'}"
      child_array+=("${child}")
    done
  fi

  # prepare overall line numbers
  for parent in "${parent_lines[@]}"; do
    parent="${parent##*_N}"
    next_line=$(( $parent + 1 ))
    remove_lines+=("${parent}")
    if [[ -n "${child_array[@]}" ]]; then
      for (( ch = 0; ch < "${#child_array[@]}"; ch++ )); do
        # note: this may not work for files with 99+ lines
        if [[ "${child_array[*]}" =~ "${next_line}" ]]; then
          remove_lines+=("${next_line}")
          next_line=$(( $next_line + 1 ))
        else
          # if lines are not consecutive, break
          break;
        fi
      done
    fi
  done

  # iteratevely delete line numbers and adjust line number accordingly
  for (( li = 0; li < "${#remove_lines[@]}"; li++ )); do
    remove_line="${remove_lines[${li}]}"
    remove_line=$(( $remove_line - $line_counter ))
    sed -i "${remove_line}d" "${yb_file}"
    line_counter=$(( $line_counter + 1 ))
  done
}

########################################
# Remove a value
# Globals:
#   yb_key_option
#   yb_query_result
#   yb_file
########################################
_remove_value(){
  declare -a parent_lines
  declare -a child_lines
  declare -a child_array
  declare -a remove_lines
  local next_line
  local remove_line
  local line_counter=0
  local line_number
  local line_type
  local result
  local spacing="\ \ "
  local spacer=""
  local last_key_index
  local last_key

  yb_show_line=true
  yb_silent_query=true

  _query_search_values "${yb_key_option}"
  result=("${yb_query_result}")

  if [[ "${result}" == false ]]; then
    return 0
  fi

  for (( rs = 0; rs < "${#result[@]}" ; rs++ )); do
    line_type="${result[$rs]##*'{{T_'}"
    line_type="${line_type%%'}}{{N_'*}"
    line_number="${result[$rs]##*'{{N_'}"
    line_number="${line_number%%'}}'}"
    line_number=$(( $line_number - $line_counter ))

    if [[ "${line_type}" == *"key:value" ]]; then
      sed -i "${line_number}d" "${yb_file}"
      line_number=$(( $line_number - 1 ))

      # create spacer
      for (( sp = 0; sp < $yb_key_length - 1; sp++ )); do
        spacer+="${spacing}"
      done

      # find key
      last_key_index=$(( $yb_key_length - 1 ))
      last_key="${yb_keys[$last_key_index]}"
      if [[ "${line_type}" == "key:value" ]]; then
        last_key="${spacer}${last_key}:"
      elif [[  "${line_type}" == "list-key:value" ]]; then
        last_key="${spacer}${last_key}:"
      fi
      # re-add the key
      sed -i "${line_number} a ${last_key}" "${yb_file}"
    else
      sed -i "${line_number}d" "${yb_file}"
      # increment line count
      line_counter=$(( $line_counter + 1 ))
    fi
  done

  # reset flag
  yb_show_line=false
  yb_silent_query=false
}

########################################
# Build the spacer that comes before a key or value
# Globals:
#   $yb_spacer
# Attributes:
#   $2 # current $type
#   $2 # current $type
########################################
_build_spacer(){
  local level=${1-}
  local type=${2-}
  local parent=${3-}
  local style=""
  local separator=""
  local spacer=""

  # set the correct starting level
  if [[ ${yb_is_sequence} == true ]]; then
    level=$(( $level - 1 ))
  else 
    level=$(( $level + 1 ))
  fi

  # switch the separator type
  if [[  "${yb_format}" == true ]]; then
    style="."
    separator="${style}"
    level=$(( $level + 1 ))
  else
    style=" "
    # set the separator length based one
    for (( i = 0; i < $yb_spacing; i++ )); do
      separator+="${style}"
    done
  fi

  level=$(_set_level "${level}")

  for (( i = 0; i < $level; i++ )); do
    spacer+="${separator}"
  done
  
  if [[ "${type}" == *"value"* && "${yb_format}" == true ]]; then
      spacer+="${parent}_"
  fi
  yb_spacer="${spacer}"
}

########################################
# Set the correct level depending on -options
# Globals:
#   yb_is_sequence
#   yb_depth
#   yb_is_array
#   yb_format
#   yb_key_base_level
# Attributes:
#   $1 # current $level
########################################
_set_level(){
  local level="${1-}"

  # set the correct level number
  if [[ ${yb_is_sequence} == false ]]; then
    level=$(( $level - 1 ))
  elif [[ ${yb_depth} == true ]]; then
    level=$(( $level + 1 ))
  elif [[ "${yb_is_array}" == true && "${yb_format}" == false ]]; then
    level=0
  elif [[ "${yb_is_sequence}" == true ]]; then
    local base_level="${yb_key_base_level}"
    level=$(( $level - $base_level ))
  fi

  echo "${level}"
}

########################################
# Build the outer that comes after a key or value
# Globals:
#   $yb_outer
# Attributes:
#   $1 # current $level
#   $2 # current $line_number
########################################
_build_outer(){
  local outer=""
  local line_spacer="{{line}}"
  local line_level_spacer="${1-}"
  local line_number_spacer="${2-}"
  local line_level_spacer="{{${line_level_spacer}}}"
  local line_number_spacer="{{${line_number_spacer}}}"

  # add an outer {{line}} for each line
  if [[ "${yb_show_line}" == true ]]; then
    outer+="${line_spacer}"
  fi
  # add an outer {{$level}} for each line
  if [[ "${yb_show_level}" == true ]]; then
    outer+="${line_level_spacer}"
  fi
  # add an outer {{$line_number}} for each line
  if [[ "${yb_show_line_number}" == true ]]; then
    outer+="${line_number_spacer}"
  fi
  yb_outer="${outer}"
}

########################################
# Check for a value type
# Attributes:
#   $1 # a value
########################################
_value_type(){
  local value="${1-}"
  if [[ "${value}" == "true" || "${value}" == "false" ]]; then
    _set_color "${value}" "${yb_red}"
    yb_value="${yb_color_string}"
    yb_is_colored=true
  elif [[ "${value}" =~ ^[0-9]+$ ]]; then
    _set_color "${value}" "${yb_orange}"
    yb_value="${yb_color_string}"
    yb_is_colored=true
  fi
}

########################################
# Trim leading and trailing spaces
# Attributes:
#   $1 # string
########################################
_trim_space(){
  local string="${@-}"

  string="${string#"${string%%[![:space:]]*}"}"
  string="${string%"${string##*[![:space:]]}"}"

  yb_trimmed="${string}"
}

########################################
# Trim a leading hyphen and one space
# Attributes:
#   $1 # string
########################################
_trim_hyphen(){
  local string="${@-}"

  # string="${string##*- }"
  string="${string#- }"

  yb_trimmed="${string}"
}

########################################
# Add some color tags to a string
# Attributes:
#   $1 # string
#   $2 # an ANSI format color
########################################
_set_color(){
  local text="${1-}"
  local color="${2-}"
  yb_color_string="${color}${text}\033[0m"
}

########################################
# Prepare globals for sequence search
# Attributes:
#   $1 # a yaml key
########################################
_search_sequence(){
  local key=${@:-"${yb_key_option}"}

  # set flags
  yb_is_sequence=true
  yb_retrieve=false

  _key_to_array "${key}"
}

########################################
# Parse script options
# Attributes:
#   $@ # getopts options
# Globals:
#   yb_line_number_query
########################################
_parse_options(){
  local file="${yb_file-}"
  local key="${yb_key_option-}"




  if [[ -f ${file} ]]; then

    _cache_yaml "${yb_file}"

    if [[ "${yb_query}" == true ]]; then
      if [[ -n "${yb_value_option}" ]]; then
        _query_search_values "${key}"
        if [[ "${yb_query_result}" == false ]]; then
          echo "${yb_query_result}"
        fi
      else
        _query_search "${key}"
        echo "${yb_query_result}"
      fi
    elif [[ "${yb_add}" == true ]]; then
      _add
    elif [[ "${yb_remove}" == true ]]; then
      if [[ -n "${yb_value_option}" ]]; then
        _remove_value
      else
        _remove
      fi
    elif [[ -n "${key}" ]]; then
      _search_sequence
    fi
  else
    echo "YAML file needs to be provided through the '-f' option."
    exit
  fi
}

########################################
# Cache yaml file into a global variable
# Attributes:
#   $1 # a yaml file path
########################################
_cache_yaml(){
  local file="${1:-${yb_file}}"
  yb_YAML=$(<"${file}")
}

########################################
# Dump array, print an error and exit
########################################
_exit_dump() {
  echo "${yb_array[@]}"
  _error "${@-}"
  exit 1
}

########################################
# Print an error and exit
########################################
_exit() {
  _error "${@-}"
  exit 1
}

########################################
# Print an error message in STDERR
########################################
_error() {
  echo "${FUNCNAME[1]} : [$(date +'%Y-%m-%dT%H:%M:%S%z')]:: ${@-}" >&2 ":: ${*#"${@}"}"
}

########################################
# Initialize the cli
# Attributes:
#   $@ # script user options
########################################
_cli(){
  while getopts "aAdf:Fk:lLnqrRs:v:" arg; do
    case $arg in
      a)
        yb_add=true
        ;;
      A)
        yb_is_array=true
        ;;
      d)
        yb_depth=true
        ;;
      f)
        yb_file="${OPTARG}"
        ;;
      F)
        yb_format=true
        ;;
      k)
        yb_key_option="${OPTARG}"
        ;;
      l)
        yb_show_line=true
        ;;
      L)
        yb_show_level=true
        ;;
      q)
        yb_query=true
        ;;
      n)
        yb_show_line_number=true
        ;;
      r)
        yb_remove=true
        ;;
      R)
        yb_is_raw=true
        ;;
      v)
        yb_value_option="${OPTARG}"
        ;;
      s)
        yb_spacing="${OPTARG}"
        ;;
    esac
  done
  # if no options were provided
  if [[ "${OPTIND}" -eq 1 ]]; then
    # if arguments were provided
    if [[ "${#}" -gt 0 ]]; then
      yb_file="${1-}"
      yb_key_option="${2-}"
    else
      echo "No parameters provided"
      exit
    fi
  fi
}

########################################
# Main function
# Attributes:
#   $@ # script user options
########################################
main(){
  trap _exit_dump SIGINT
  _globals
  _cli "${@}"
  _parse_options "${@}"

  if [[ "${yb_add}" == false && "${yb_remove}" == false && "${yb_query}" == false ]]; then
    _parse_yaml "${yb_file}"
  fi

  if [[ "${yb_is_array}" == true ]]; then
    echo "${yb_array[@]}"
  fi
}

# Launch main function
main "${@}"
# Unset the eu flag
set +eu