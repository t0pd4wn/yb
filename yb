#!/bin/bash
#---------------------------------------
# yb | yaml bash parser
#---------------------------------------

# Set the eu flag
set -eu

########################################
# Declare globals
# Attributes:
#   $@ # script user options
########################################
_globals(){
  declare -g yb_spacing=2
  declare -g yb_grey="\033[0;30m"
  declare -g yb_blue="\033[1;36m"
  declare -g yb_orange="\033[1;33m"
  declare -g yb_red="\033[31m"
  declare -g yb_add=false
  declare -g yb_query=false
  declare -g yb_boolean_query=false
  declare -g yb_line_number_query=false
  declare -g yb_line_number_query_result=()
  declare -g yb_depth=false
  declare -g yb_format=false
  declare -g yb_is_array=false
  declare -g yb_is_raw=false
  declare -g yb_show_level=false
  declare -g yb_show_line=false
  declare -g yb_show_line_number=false
  declare -g yb_is_sequence=false
  declare -g yb_sequence_retrieved=0
  declare -g yb_is_empty=true
  declare -g yb_has_key=false
  declare -g yb_key_length=0
  declare -g yb_key_step=0
  declare -g yb_key_base_level=0
  declare -g yb_retrieve=false
  declare -g yb_is_retrieved=false
  declare -g yb_is_print=false
  declare -g yb_one_line=false
  declare -g yb_is_colored=false
  declare -g yb_previous_parent=""
  declare -g yb_value=""
  declare -g yb_key=""
  declare -g yb_YAML=""
  declare -ga yb_array
}

########################################
# Parse a yaml file
# Globals:
#   yb_YAML
########################################
_parse_yaml() {
  local comment
  local yaml
  local separator
  local line
  local spaces
  local level
  local type
  local key=""
  local value=""
  local parent=""
  local line_number=0
  local prefix
  local suffix

  # global associative array
  declare -A line_structure

  # Set whitespace as field separator
  IFS=$' \t\n'

  # Loop through each line of the YAML file
  while IFS= read -r line; do
    # keep track of current line number
    ((line_number += 1))

    # reset variables values
    key=""
    value=""
    suffix=""
    prefix=""

    # Count the leading spaces to determine the indentation level
    spaces="${line%%[^[:space:]]*}"
    level="${#spaces}"
    level="$(( level / yb_spacing + 1 ))"

    # Remove the leading and trailing spaces
    line=$(_trim_space "${line}")

    # Check the line type
    if [[ -z "${line}" ]]; then 
      type="empty"
    elif [[ "${line}" == "#"* ]]; then
      type="comment"
      value="${line}"
    elif [[ "${line}" == *":" && "${line}" != "-"*":"* ]]; then
      type="key"
      key="${line%%:*}"
      parent="${key}"
      yb_previous_parent="${key}"
      suffix=": "
    elif [[ "${line}" == *": "* && ${line} != "- "* ]]; then
      type="key:value"
      key="${line%%:*}"
      value="${line#*:}"
      key=$(_trim_space "${key}")
      value=$(_trim_space "${value}")
      parent="${key}"
      suffix=": "
    elif [[ "${line}" == "- "*": "* ]]; then
      type="list-key:value"
      key=$(_trim_space "${line}")
      key=$(_trim_hyphen "${key}")
      key="${key%%:*}"
      value="${line#*:}"
      value=$(_trim_space "${value}")
      prefix="- "
      suffix=": "
      # in this case, the parent is on the previous line
      parent="${yb_previous_parent}"
    elif [[ "${line}" == "-"*":" ]]; then
      # if [[ ${level} -eq 0 ]]; then
        type="list-key"
        # Trim leading space and list hyphen
        key=$(_trim_space "${line}")
        key=$(_trim_hyphen "${line}")
        key="${key%%:*}"
        prefix="- "
        parent="${key}"
        yb_previous_parent="${key}"
      elif [[ "${line}" == "-"* ]]; then
        type="list-value"
        # Trim leading space and list hyphen
        value=$(_trim_space "${line}")
        value=$(_trim_hyphen "${line}")
        prefix="- "
    else
      type="other"
      value="${line}"
    fi

    # populate the associative array
    line_structure=(
      [type]="${type}"
      [level]="${level}"
      [line_number]="${line_number}"
      [key]="${key-}"
      [value]="${value-}"
      [parent]="${parent-}"
      [prefix]="${prefix-}"
      [suffix]="${suffix-}"
    )

    # send the reference
    _manage line_structure

  done <<< "${yb_YAML}"

  # reset IFS to default value
  unset IFS

  # if a line-number query
  if [[ "${yb_line_number_query}" == true ]]; then
    echo "${yb_line_number_query_result[@]}"
  fi
}

########################################
# Manage lines structures depending on action
# Inherit:
#   ${line_structure[@]}
########################################
_manage(){
  local query_prefix="L${line_structure["level"]}_N${line_structure["line_number"]}"
  # build $spacer and $outer
  line_structure["spacer"]=$(_spacer "${line_structure["level"]}" "${line_structure["type"]}" "${line_structure["parent"]}")
  line_structure["outer"]=$(_outer "${line_structure["level"]}" "${line_structure["line_number"]}")
  # if a sequence, search if the path is correct
  if [[ "${yb_is_sequence}" == true ]]; then
     _search "${line_structure["key"]}" "${line_structure["level"]}" "${line_structure["type"]}" "${query_prefix}"
    # if correct path, print
    if [[ "${yb_is_print}" == true ]]; then
      _print
    fi
  fi
  # if regular print, print
  if [[ "${yb_is_sequence}" == false ]]; then
    _print
  fi
}

########################################
# Search the correct key path
# Attributes:
#   $1 # current $key
#   $2 # current $level
#   $3 # current $type
#   $4 # prefix for -q option
########################################
_search(){
  local key="${1-}"
  local level="${2-}"
  local type="${3-}"
  local query_prefix="${4-}"

  # if sequence hasn't been found yet
  if [[ "${yb_retrieve}" == false ]]; then
    if [[ "${key}" == "${yb_key["${yb_key_step}"]}" ]]; then
      # if sequence is found
      ((yb_key_step += 1))
      # if value is on a sub level, retrieve it
      if [[ "${yb_key_step}" -eq "${yb_key_length}" ]]; then
        if [[ "${yb_boolean_query}" == true ]]; then
          # if looking for the key existence confirm and exit
          echo true
          exit 0
        elif [[ "${yb_line_number_query}" == true ]]; then
          # if looking for the key coordinates
          yb_line_number_query_result+=("${query_prefix}")
        fi

        yb_retrieve=true
        yb_key_base_level="${level}"
        # assume the key exist
        yb_has_key=true

        # if value is *key:value, retrieve only once
        if [[ "${type}" == "key:value" ]]; then
            # search result is only one line
            yb_one_line=true
            # sequence is over, reset flags
            yb_key_step=0
            # yb_is_retrieved=false
            yb_retrieve=false
            # send a true signal to print the current line
            yb_is_print=true
            # add one to the number of retrieved sequences
            # echo "${yb_sequence_retrieved}"
            yb_sequence_retrieved=$(( yb_sequence_retrieved + 1 ))
            # assume the value was filled once
            yb_is_empty=false
            return 0
        fi
      fi
    fi
  elif [[ "${yb_retrieve}" == true && "${level}" -gt "${yb_key_base_level}" ]]; then
    # send a true signal to print the current line
    yb_one_line=false
    yb_is_print=true
    # assume the value was filled once
    yb_is_empty=false
  else
    yb_one_line=false
    yb_is_print=false
    # if the level is lower or equal the key level
    # sequence is over, reset flags
    yb_key_step=0
    # yb_is_retrieved=false
    yb_retrieve=false
    # add one to the number of retrieved sequences
    yb_sequence_retrieved=$(( yb_sequence_retrieved + 1 ))
  fi
}

########################################
# Transform original key option into an array
# Globals:
#   yb_key
#   yb_key_length
########################################
_key_to_array(){
  yb_key=($(echo "${yb_key}" | tr -s '.' ' '))
  yb_key_length="${#yb_key[@]}"
}

########################################
# Query file for an existing key
# Attributes:
#   $1 # mode (boolean verbose)
#   $2 # a key
########################################
_query(){
  local mode="${1-}"
  local key="${2-}"
  local result

  if [[ "${mode}" == "boolean" ]]; then
    yb_boolean_query=true
  elif [[ "${mode}" == "line-number" ]]; then
    yb_line_number_query=true
  fi

  _sequence "${key}"
  result=$(_parse_yaml "${yb_file}")

  if [[ "${mode}" == "boolean" ]]; then
    if [[ -n "${result}" ]]; then
      # has result
      echo true
    elif [[ "${yb_is_empty}" == false ]]; then
      # has result but empty one
      echo true
    else
      # no result
      echo false
    fi
  else
    echo "${result}"
  fi
}

########################################
# Build the key coordinates
# Globals:
#   yb_key
#   yb_key_length
########################################
_build_key_coordinates(){
  local has_key
  declare -a coordinates

  for (( i = 0; i < $yb_key_length ; i++ )); do
    has_key=$(_query "line-number" "${yb_key[$i]}")
    has_key=(${has_key})

  for key_line in "${has_key[@]}"; do
      coordinates+=("I${i}_${key_line}")
    done
  done

  echo "${coordinates[@]}"
}

########################################
# Check for existing child keys
# Attributes:
#   $1 # boolean
#   $2 # key
#   $3 # level
#   $4 # line number
########################################
_check_child_keys(){
  local check_child="${1-}"
  local parent_index="${2-}"
  local parent_level="${3-}"
  local parent_line_number="${4-}"

  if [[ "${check_child}" == true ]]; then
    _is_child_key "${parent_index}" "${parent_level}" "${parent_line_number}"
  else
    echo "I${parent_index}_L${parent_level}_N${parent_line_number}"
  fi
}

########################################
# Check if the current key as a child key
# Attributes:
#   $1 # key
#   $2 # level
#   $3 # line number
########################################
_is_child_key(){
  local parent_index="${1}"
  local parent_level="${2}"
  local parent_line="${3}"
  local child_index
  local child_level
  local child_line
  declare -a child_structure

  child_index=$(( $parent_index + 1 ))
  child_level=$(( $parent_level + 1 ))
  child_line=$(( $parent_line + 1 ))

  if [[ -v "${structure[${child_line}]+_}" ]]; then
    child_structure=($( echo "${structure[${child_line}]}"))
    if [[ "${child_structure[1]}" -eq "${child_level}" ]]; then
      # child key exist
      _check_child_keys true "${child_index}" "${child_level}" "${child_line}"
    fi
  else 
    # child key doesn't exist
    _check_child_keys false "${parent_index}" "${parent_level}" "${parent_line}"
  fi
}

########################################
# Manage keys addition
# Attributes:
#   $@ # an array pf key coordinates (index, level, line number)
########################################
_manage_add_key(){
  declare -a coordinates
  coordinates=("${@-}")

  local key_index
  local key_line
  local key_level
  local local_index
  local addition_number
  declare -A structure
  declare -a anchors

  # build the dictionary
  for coordinate in "${coordinates[@]}"; do
    key_index="${coordinate%%_L*}"
    key_index="${key_index#*I}"
    key_level="${coordinate%%_N*}"
    key_level="${key_level#*L}"
    key_line="${coordinate#*N}"
    structure+=(["${key_line}"]="${key_index} ${key_level}")
  done

  for coordinate in "${coordinates[@]}"; do
    key_index="${coordinate%%_L*}"
    key_index="${key_index#*I}"
    key_level="${coordinate%%_N*}"
    key_level="${key_level#*L}"
    key_line="${coordinate#*N}"

    # case were addition is made from root level
    if [[ "${key_index}" -eq "0" ]]; then
      anchors+=($(_check_child_keys true "${key_index}" "${key_level}" "${key_line}"))
    fi
  done

  local_index=0
  for anchor in "${anchors[@]}"; do
    key_index="${anchor%%_L*}"
    key_index="${key_index#*I}"
    key_index=$(( $key_index + 1 ))
    key_level="${anchor%%_N*}"
    key_level="${key_level#*L}"
    key_line="${anchor#*N}"
    key_line=$(( $key_line + $local_index ))
    _add_in_file "${key_line}" "${key_level}" "${key_index}"
    addition_number=$(( $yb_key_length - $key_index ))
    # increment the local index to keep the new lines count
    local_index=$(( $local_index + $addition_number ))
  done

  # reset cached yaml
  _cache_yaml "${yb_file}"
}

########################################
# Add key(s) in a file
# Attributes:
#   $1 # line number
#   $2 # level
#   $3 # index
# Globals:
#   yb_key
#   yb_key_length
########################################
_add_in_file(){
  local parent_line_number="${1-}"
  local parent_level="${2-}"
  local parent_index="${3-}"
  local spacing="\ \ "
  local spacer

  for (( i = $parent_index; i < $yb_key_length; i++ )); do 
    spacer=""
    for (( i = 0; i < $parent_level; i++ )); do
      spacer+="${spacing}"
    done
    child_key="${spacer}${yb_key[${i}]}:"
    sed -i "${parent_line_number} a ${child_key}" "${yb_file}"
    parent_level=$(( $parent_level + 1 ))
    parent_line_number=$(( $parent_line_number + 1 ))
  done
}

########################################
# Add key(s) and/or value(s)
# Globals:
#   yb_key
########################################
_add(){
  local has_key
  declare -a coordinates
  has_key=$(_query "boolean" "${yb_key}")

  if [[ "${has_key}" == false ]]; then
    _key_to_array
    coordinates=($(_build_key_coordinates))
    _manage_add_key "${coordinates[@]}"
  fi
}

########################################
# Build the spacer that comes before a key or value
# Attributes:
#   $1 # current $level
#   $2 # current $type
########################################
_spacer(){
  local level=${1-}
  local type=${2-}
  local parent=${3-}
  local style=""
  local separator=""
  local spacer=""

  # switch the separator type
  if [[  "${yb_format}" == true ]]; then
    style="."
    level=$(( $level ))
    separator="${style}"
  else
    style=" "
    level=$(( $level - 1 ))
    # set the separator length based one
    for (( i = 0; i < $yb_spacing; i++ )); do
      separator+="${style}"
    done
  fi

  level=$(set_level "${level}")

  for (( i = 0; i < $level; i++ )); do
    spacer+="${separator}"
  done
    
  if [[ "${type}" == *"value"* && "${yb_format}" == true ]]; then
      spacer+="${parent}_"
  fi

  echo "${spacer}"
}

########################################
# Set the correct level depending on -options
# Attributes:
#   $1 # current $level
########################################
set_level(){
  local level="${1-}"

  # set the correct level number
  if [[ ${yb_is_sequence} == false ]]; then
    level=$(( $level -1 ))
  elif [[ ${yb_depth} == true ]]; then
    level="${level}"
  elif [[ "${yb_is_array}" == true && "${yb_format}" == false ]]; then
    level=0
  elif [[ "${yb_is_sequence}" == true ]]; then
    local base_level="${yb_key_base_level}"
    level=$(( $level - $base_level ))
  fi

  echo "${level}"
}

########################################
# Build the outer that comes after a key or value
# Attributes:
#   $1 # current $level
#   $2 # current $type
########################################
_outer(){
  local outer=""
  local line_spacer="{{line}}"
  local line_level_spacer="{{${1-}}}"
  local line_number_spacer="{{${2-}}}"

  # add an outer {{line}} for each line
  if [[ "${yb_show_line}" == true ]]; then
    outer+="${line_spacer}"
  fi
  # add an outer {{$level}} for each line
  if [[ "${yb_show_level}" == true ]]; then
    outer+="${line_level_spacer}"
  fi
  # add an outer {{$line_number}} for each line
  if [[ "${yb_show_line_number}" == true ]]; then
    outer+="${line_number_spacer}"
  fi
  echo "${outer}"
}

########################################
# Check for a value type
# Attributes:
#   $1 # a value
########################################
_value_type(){
  local value="${1-}"
  if [[ "${value}" == "true" || "${value}" == "false" ]]; then
    yb_value=$(_to_color "${value}" "${yb_red}")
    yb_is_colored=true
  elif [[ "${value}" =~ ^[0-9]+$ ]]; then
    yb_value=$(_to_color "${value}" "${yb_orange}")
    yb_is_colored=true
  fi
}

########################################
# Print to terminal
# Inherit:
#   ${line_structure[@]}
########################################
_print(){
  local level=${line_structure["level"]}
  local type="${line_structure["type"]}"
  local key="${line_structure["key"]}"
  local value="${line_structure["value"]}"
  local prefix="${line_structure["prefix"]}"
  local suffix="${line_structure["suffix"]}"
  local line_number="${line_structure["line_number"]}"
  local spacer="${line_structure["spacer"]}"
  local outer="${line_structure["outer"]}"
  local string=""
  local has_colors=""
  yb_is_colored=false
  yb_value=""

  # if a line-number query
  if [[ "${yb_line_number_query}" == true ]]; then
    return 1
  fi

  if [[ "${yb_is_array}" == true ]]; then
    if [[ "${type}" != "comment" && "${type}" != "empty" ]]; then
      if [[ "${type}" == *"key"* ]]; then
        if [[ "${type}" == "list-key:value" ]]; then
          yb_array+=("${spacer}${key}_ ${value}${outer}")
        else
          yb_array+=("${spacer}${key}_${value}${outer}")
        fi
      else
        yb_array+=("${spacer}${value}${outer}")
      fi
    fi
  else
    # if '-R' is false, use colors
    if [[ "${yb_is_raw}" == false ]] && [[ "${yb_format}" == false ]]; then
      

      # echo ${type}
      if [[ "${type}" == "comment" ]]; then
        value=$(_to_color "${value}" "${yb_grey}")
      elif [[ "${line_structure["type"]}" == *"key"* ]]; then
        key=$(_to_color "${key}" "${yb_blue}")
        prefix=$(_to_color "${prefix}" "${yb_blue}")
      fi
      if [[ "${line_structure["type"]}" == *"value"* ]]; then
        # echo "VALUE"
        _value_type "${value}"
        if [[ -n "${yb_value}" ]]; then
          value="${yb_value}"
        fi
      fi
    fi

    if [[ "${yb_is_sequence}" == true && "${yb_one_line}" == true ]]; then
      if [[ "${type}" == *"key:value" ]]; then
        string=$(echo "${value}${outer}")
        yb_one_line=false
        yb_is_print=false
        echo "${spacer}"${string}
      fi
    else
      if [[ "${type}" == "comment" ]]; then
        string=$(echo -e "${prefix}${value}${outer}")
        echo "${spacer}"${string}
      else
        if [[ ${yb_is_colored} == true ]]; then
         string=$(echo -e "${prefix}${key}${suffix}${value}${outer}")
        else
         string=$(echo -e "${prefix}${key}${suffix}" && echo "${value}${outer}")
        fi
        echo "${spacer}"${string}
      fi
    fi
  fi
}

########################################
# Trim leading and trailing spaces
# Attributes:
#   $1 # string
########################################
_trim_space(){
  local string="${@-}"
  string=$(echo "$string" | sed -E 's/^ +//')
  string=$(echo "$string" | sed -E 's/ +$//')
  echo "${string}"
}

########################################
# Trim a leading hyphen and one space
# Attributes:
#   $1 # string
########################################
_trim_hyphen(){
  local string="${@-}"
  string="${string##*- }"
  echo "${string}"
}

########################################
# Add some color tags to a string
# Attributes:
#   $1 # string
#   $2 # an ANSI format color
########################################
_to_color(){
  local text="${1-}"
  local color="${2-}"
  echo "${color}${text}\033[0m"
}

########################################
# Prepare globals for sequence search
# Attributes:
#   $1 # a yaml key
########################################
# key_sequence ?
_sequence(){
  local key=${1:-"${yb_key}"}
  # set flags
  yb_is_sequence=true
  yb_retrieve=false
  # get selector key details
  yb_key=($(echo "${key}" | tr -s '.' ' '))
  yb_key_length="${#yb_key[@]}"
}

########################################
# Parse script options
# Attributes:
#   $@ # getopts options
########################################
_parse_options(){
  local file="${yb_file-}"
  local key="${yb_key-}"
  if [[ -f ${file} ]]; then

    _cache_yaml "${yb_file}"

    if [[ "${yb_query}" == true ]]; then
      _query "boolean"
      exit 0
    elif [[ "${yb_add}" == true ]]; then
      _add
    elif [[ -n "${key}" ]]; then
      _sequence
    fi

  else
    echo "YAML file needs to be provided through the '-f' option."
    exit
  fi
}

########################################
# Cache yaml file into a global variable
# Attributes:
#   $1 # a yaml file path
########################################
_cache_yaml(){
  local file="${1-}"
  yb_YAML=$(<"${file}")
}

########################################
# Dump array, print an error and exit
########################################
_exit_dump() {
  echo "${yb_array[@]}"
  _error "${@-}"
  exit 1
}

########################################
# Print an error and exit
########################################
_exit() {
  _error "${@-}"
  exit 1
}

########################################
# Print an error message in STDERR
########################################
_error() {
  echo "[$(date +'%Y-%m-%dT%H:%M:%S%z')]:: ${@-}" >&2 ":: ${*#"${@}"}"
}

########################################
# Initialize the cli
# Attributes:
#   $@ # script user options
########################################
_cli(){
  while getopts "aAdf:Fk:lLnqRs:v:" arg; do
    case $arg in
      a)
        yb_add=true
        ;;
      A)
        yb_is_array=true
        ;;
      d)
        yb_depth=true
        ;;
      f)
        yb_file="${OPTARG}"
        ;;
      F)
        yb_format=true
        ;;
      k)
        yb_key="${OPTARG}"
        ;;
      l)
        yb_show_line=true
        ;;
      L)
        yb_show_level=true
        ;;
      q)
        yb_query=true
        ;;
      n)
        yb_show_line_number=true
        ;;
      R)
        yb_is_raw=true
        ;;
      v)
        yb_value="${OPTARG}"
        ;;
      s)
        yb_spacing="${OPTARG}"
        ;;
    esac
  done
  # if no options were provided
  if [[ "${OPTIND}" -eq 1 ]]; then
    # if arguments were provided
    if [[ "${#}" -gt 0 ]]; then
      yb_file="${1-}"
      yb_key="${2-}"
    else
      echo "No parameters provided"
      exit
    fi
  fi
}

########################################
# Main function
# Attributes:
#   $@ # script user options
########################################
main(){
  trap _exit_dump SIGINT
  _globals
  _cli "${@}"
  _parse_options "${@}"

  if [[ "${yb_add}" == false && "${yb_query}" == false ]]; then
    _parse_yaml "${yb_file}"
  fi

  if [[ "${yb_is_array}" == true ]]; then
    echo "${yb_array[@]}"
  fi
}

# Launch main function
main "${@}"
# Unset the eu flag
set +eu