#!/bin/bash
#---------------------------------------
# yb | yaml bash parser
#---------------------------------------

# Set the eu flag
set -eu

########################################
# Declare globals
# Attributes:
#   $@ # script user options
########################################
yb::main::globals(){
  declare -g yb_spacing=2
  declare -g yb_pipe_delimeter="|>"
  declare -g yb_grey="\033[0;30m"
  declare -g yb_blue="\033[1;36m"
  declare -g yb_orange="\033[1;33m"
  declare -g yb_red="\033[31m"
  declare -g yb_italic="\033[3m"
  declare -g yb_add=false
  declare -g yb_remove=false
  declare -g yb_query=false
  declare -g yb_type=false
  declare -g yb_boolean_query=false
  declare -g yb_value_query=false
  declare -g yb_line_number_query=false
  declare -g yb_silent_query=false
  declare -g yb_depth=false
  declare -g yb_format=false
  declare -g yb_is_array=false
  declare -g yb_is_raw=false
  declare -g yb_show_level=false
  declare -g yb_show_line=false
  declare -g yb_show_line_number=false
  declare -g yb_is_sequence=false
  declare -g yb_is_empty=true
  declare -g yb_retrieve=false
  declare -g yb_is_retrieved=false
  declare -g yb_is_print=false
  declare -g yb_one_line=false
  declare -g yb_is_colored=false
  declare -g yb_has_key=false
  declare -g yb_sequence_retrieved=0
  declare -g yb_original_key_length=""
  declare -g yb_key_length=0
  declare -g yb_key_step=0
  declare -g yb_key_base_level=0
  declare -g yb_added_lines=0
  declare -g yb_previous_parent=""
  declare -g yb_parent_type=""
  declare -g yb_parent_level=""
  declare -g yb_set_level=""
  declare -g yb_line=""
  declare -g yb_value=""
  declare -g yb_value_type=""
  declare -g yb_key_option=""
  declare -g yb_value_option=""
  declare -g yb_YAML=""
  declare -g yb_trimmed=""
  declare -g yb_spacer=""
  declare -g yb_anchor=""
  declare -g yb_color_string=""
  declare -g yb_query_search_result=""
  declare -g yb_query_lines_result=""
  declare -g yb_query_search_values_result=""
  declare -g yb_query_pipe_result=""
  declare -g yb_query_pipe_first_line=""
  declare -ga yb_coordinates
  declare -ga yb_query_result
  declare -ga yb_array
  declare -gA yb_keys
}

########################################
# Parse a yaml file
# Globals:
#   yb_YAML
#   yb_line
#   yb_trimmed
#   yb_spacing
########################################
yb::parse::yaml() {
  local raw_line
  local spaces
  local level
  local line_number=0

  # associative array that holds the $yb_line information
  # it is made available to the yb::parse::* functions
  declare -A line_

  # set whitespace as field separator
  IFS=$' \t\n'

  # loop through each line of the YAML file
  while IFS= read -r raw_line; do
    # reset variables values
    line_["level"]=""
    line_["line_number"]=""
    line_["key"]=""
    line_["value"]=""
    line_["parent"]=""
    line_["prefix"]=""
    line_["suffix"]=""
    yb_trimmed=""

    # keep track of current line number
    line_number=$(( $line_number + 1 ))
    line_["line_number"]="${line_number}"

    # copy the raw line to $yb_line
    # used to retrieve original spacing for pipe selection
    yb_line="${raw_line}"

    # count the leading spaces to set the indentation level
    spaces="${yb_line%%[^[:space:]]*}"
    level="${#spaces}"
    line_["level"]="$(( $level / $yb_spacing ))"

    # remove the leading and trailing spaces
    _trim_space "${yb_line}"
    yb_line="${yb_trimmed}"

    # check the line type
    if [[ -z "${yb_line}" ]]; then 
      line_["type"]="empty"
    elif [[ "${yb_line}" == "#"* ]]; then
      yb::parse::yaml::comment
    elif [[ "${yb_line}" == *":" && "${yb_line}" != "-"*":"* ]]; then
      yb::parse::yaml::key
    elif [[ "${yb_line}" == *": "* && ${yb_line} != "- "* ]]; then
      yb::parse::yaml::key_value
    elif [[ "${yb_line}" == "- "*": "* && "${yb_line}" != *"::"* ]]; then
      yb::parse::yaml::list_key_value
    elif [[ "${yb_line}" == "-"*":"  && "${yb_line}" != *"::"* ]]; then
      yb::parse::yaml::list_key
    elif [[ "${yb_line}" == "-"* ]]; then
      yb::parse::yaml::list_value
    else
      yb::parse::yaml::other
    fi

    # call the filtering function
    yb::parse::filter

  done <<< "${yb_YAML}"

  # reset IFS to default value
  unset IFS
}

########################################
# Parse the type comment
# Globals:
#   $yb_line
# Inherit:
#   ${line_[@]}
########################################
yb::parse::yaml::comment(){
  line_["type"]="comment"
  line_["value"]="${yb_line}"
}

########################################
# Parse the type key
# Globals:
#   $yb_line
# Inherit:
#   ${line_[@]}
########################################
yb::parse::yaml::key(){
  line_["type"]="key"
  line_["key"]="${yb_line%%:*}"
  line_["parent"]="${line_["key"]}"
  line_["suffix"]=": "
  yb_previous_parent="${line_["key"]}"
  yb_parent_type="key"
}

########################################
# Parse the type key:value
# Globals:
#   $yb_line
# Inherit:
#   ${line_[@]}
########################################
yb::parse::yaml::key_value(){
  line_["key"]="${yb_line%%:*}"
  line_["value"]="${yb_line#*:}"
  _trim_space "${line_["key"]}"
  line_["key"]="${yb_trimmed}"
  _trim_space "${line_["value"]}"
  line_["value"]="${yb_trimmed}"
  line_["parent"]="${line_["key"]}"
  line_["suffix"]=": "

  # check if a pipe value
  if [[ "${line_["value"]}" == "|" ]]; then
    line_["type"]="key:pipe"
    yb_parent_type="key:pipe"
    yb_parent_level="${line_["level"]}"
  else
    line_["type"]="key:value"
    yb_parent_type="key:value"
  fi
}

########################################
# Parse the type list-key:value
# Globals:
#   $yb_line
# Inherit:
#   ${line_[@]}
########################################
yb::parse::yaml::list_key_value(){
  line_["type"]="list-key:value"
  yb_parent_type="list-key:value"
  # trim leading space and list hyphen
  _trim_space "${yb_line}"
  _trim_hyphen "${yb_trimmed}"
  line_["key"]="${yb_trimmed}"
  line_["key"]="${line_["key"]%%:*}"
  line_["value"]="${yb_line#*:}"
  _trim_space "${line_["value"]}"
  line_["value"]="${yb_trimmed}"
  line_["prefix"]="- "
  line_["suffix"]=": "

  # in this case, the parent is on the previous line
  line_["parent"]="${yb_previous_parent}"
  if [[ "${line_["value"]}" == "|" ]]; then
    line_["type"]="list-key:pipe"
    yb_parent_type="list-key:pipe"
    yb_parent_level="${line_["level"]}"
  fi
}

########################################
# Parse the type list-key
# Globals:
#   $yb_line
# Inherit:
#   ${line_[@]}
########################################
yb::parse::yaml::list_key(){
  line_["type"]="list-key"
  yb_parent_type="list-key"
  # trim leading space and list hyphen
  _trim_space "${yb_line}"
  _trim_hyphen "${yb_trimmed}"
  line_["key"]="${yb_trimmed}"
  line_["key"]="${line_["key"]%%:*}"
  line_["prefix"]="- "
  line_["parent"]="${line_["key"]}"
  yb_previous_parent="${line_["key"]}"
}

########################################
# Parse the type list-value
# Globals:
#   $yb_line
# Inherit:
#   ${line_[@]}
########################################
yb::parse::yaml::list_value(){
  line_["type"]="list-value"
  # Trim leading space and list hyphen
  _trim_space "${yb_line}"
  _trim_hyphen "${yb_trimmed}"
  line_["value"]="${yb_trimmed}"
  line_["prefix"]="- "
}

########################################
# Parse the type other
# Globals:
#   $yb_line
# Inherit:
#   $raw_line
#   ${line_[@]}
########################################
yb::parse::yaml::other(){
  line_["type"]="other"
  line_["value"]="${yb_line}"
  if [[ "${yb_parent_type}" == *"key:pipe" ]]; then
    line_["type"]="pipe-value"
    line_["value"]="${raw_line}"
    line_["level"]=$(( $yb_parent_level + 1 ))
  fi
}

########################################
# Manage lines structures depending on action
# Globals:
#   $yb_is_sequence
#   $yb_is_print
# Inherit:
#   ${line_[@]}
########################################
yb::parse::filter(){
  # build $spacer and $outer
  yb::string::build_spacer
  yb::string::build_outer

  # if a sequence, search if the path is correct
  if [[ "${yb_is_sequence}" == true ]]; then
    if [[ "${yb_line_number_query}" == true ]]; then
      yb::parse::search
    else
     yb::parse::search
    fi
    if [[ "${yb_is_print}" == true ]]; then
      yb::parse::print
    fi
  # if regular print, print
  elif [[ "${yb_is_sequence}" == false ]]; then
    yb::parse::print
  fi
}

########################################
# Search the correct key path
# Globals:
#   $yb_is_print
#   $yb_key_step
#   $yb_retrieve
#   $yb_keys
#   $yb_original_key_step
# Inherit:
#   ${line_[@]}
########################################
yb::parse::search(){
  local query_prefix
  local key="${line_["key"]-}"
  local new_level
  yb_is_print=false
  # if the current level is lower than the expected one, reset
  if [[ "${line_["level"]}" -lt "${yb_key_step}" ]]; then
    yb_key_step=0
    yb_retrieve=false
  fi

  # if the current step (base 0) is equal to the total ones (base 1), reset
  if [[ "${yb_key_step}" -eq "${yb_original_key_length}" ]]; then
    yb_key_step=0
  fi

  # if the current key introduces a pipe value
  if [[ "${line_["type"]}" == *"key:pipe" ]]; then
    if [[ ${yb_keys[${yb_key_step}]} == *"|" ]]; then
      key="${key}|"
    fi
  fi

  # if retrieve is false, check for current state
  if [[ "${yb_retrieve}" == false ]]; then
    # if the current key is the expected one
    if [[ "${line_["prefix"]}${key}" == "${yb_keys[${yb_key_step}]}" ]]; then
      # if the current level is the expected one
      if [[ "${line_["level"]}" -eq "${yb_key_step}" ]]; then
        # set new index
        yb_key_step=$(( $yb_key_step + 1 ))
        # check for a nested key pipe
        yb::parse::search::is_nested_pipe
        # if current level match sequence length
        if [[ "${yb_key_step}" -eq "${yb_key_length}" ]]; then
          # set retrieve options and actions
          yb::parse::search::retrieve_options
        fi
      fi
    fi
  # if retrieve is true, check conditions are still met
  elif [[ "${yb_retrieve}" == true  ]]; then
    yb::parse::search::is_retrievable
  fi
}

########################################
# Check if the sequence is retrievable
# Globals:
#   $yb_retrieve
#   $yb_key_base_level
#   $yb_has_key
#   $yb_line_number_query
#   $yb_boolean_query
# Inherit:
#   ${line_[@]}
########################################
yb::parse::search::retrieve_options(){
 # set retrieve flag to true
  yb_retrieve=true
  # set the base level to the current key one
  yb_key_base_level="${line_["level"]}"
  # assume the key exist
  yb_has_key=true
  # if a query value, parse specifically
  if [[ "${yb_line_number_query}" == true || "${yb_boolean_query}" == true ]]; then
    yb::parse::search::is_query
    return 0
  fi
  # if searched value is *key:value, retrieve only once
  if [[ "${line_["type"]}" == *"key:value" ]]; then
    yb::parse::search::is_key_value
    return 0
  fi
}

########################################
# Check if the ancestor is a pipe key
# Globals:
#   $yb_key_step
#   $yb_original_key_length
# Inherit:
#   ${line_[@]}
########################################
yb::parse::search::is_nested_pipe(){
  if [[ "${line_["type"]}" == *"key:pipe" ]]; then 
    if [[ ${yb_key_step} -lt ${yb_original_key_length} ]]; then
      echo "yb: pipe type key can not be nested in another pipe type key."
      exit 0
    fi
  fi
}

########################################
# Check if a query type search
# Globals:
#   $yb_line_number_query
#   $yb_query_lines_result
#   $yb_key_step
#   $yb_boolean_query
#   $yb_query_result
#   yb_add
# Inherit:
#   ${line_[@]}
########################################
yb::parse::search::is_query(){
  local query_prefix
  if [[ "${yb_line_number_query}" == true ]]; then
    # if looking for the key coordinates
    query_prefix="L${line_["level"]}_N${line_["line_number"]}"
    yb_query_lines_result+=("${query_prefix}")
  elif [[ "${yb_boolean_query}" == true ]]; then
    # if looking for the key existence confirm and exit
    yb_query_result=true
    if [[ "${yb_add}" == false ]]; then
      # if not in an addition scenario
      # echo and reset search
      echo ${yb_query_result}
    fi
  fi

  # query result found, reset flag and counter
  yb_retrieve=false
  yb_key_step=0
}

########################################
# Check if a key:value search
# Globals:
#   $yb_one_line
#   $yb_key_step
#   $yb_retrieve
#   $yb_is_print
#   $yb_sequence_retrieved
#   $yb_is_empty
########################################
yb::parse::search::is_key_value(){
  # search result is only one line
  yb_one_line=true
  # sequence is over, reset flags
  yb_key_step=0
  yb_retrieve=false
  # send a true signal to print the current line
  yb_is_print=true
  # add one to the number of retrieved sequences
  yb_sequence_retrieved=$(( yb_sequence_retrieved + 1 ))
  # assume the value was filled once
  yb_is_empty=false
}

########################################
# Check if the sequence can be retrieved
# Globals:
#   $yb_key_base_level
#   $yb_key_step
#   $yb_retrieve
#   $yb_is_print
#   $yb_sequence_retrieved
#   $yb_is_empty
# Inherit:
#   ${line_[@]}
########################################
yb::parse::search::is_retrievable(){
  if  [[ "${line_["level"]}" -gt "${yb_key_base_level}" ]]; then
    # if search parameters match with current base level,
    # send a true signal to print the current line
    yb_one_line=false
    yb_is_print=true
    # assume the value wask filled once
    yb_is_empty=false
  else
    # if the level is lower or equal the key level
    yb_one_line=false
    yb_is_print=false
    # sequence is over, reset flags
    yb_key_step=0
    yb_retrieve=false
    # add one to the number of retrieved sequences
    yb_sequence_retrieved=$(( yb_sequence_retrieved + 1 ))
  fi
}

########################################
# Print to terminal
# Globals:
#   $yb_is_colored
#   $yb_value
#   $yb_value_type
#   $yb_line_number_query
#   $yb_boolean_query
#   $yb_type
#   $yb_value_query
#   $yb_is_array
#   $yb_is_raw
#   $yb_format
# Inherit:
#   ${line_[@]}
########################################
yb::parse::print(){
  # reset flags and temp values
  yb_is_colored=false
  yb_value=""
  yb_value_type=""

  # if a line-number query or a boolean query, return
  # note: they are dealt with in yb::parse::search
  if [[ "${yb_line_number_query}" == true || "${yb_boolean_query}" == true ]]; then
    return 0
  fi

  # if '-T' is true
  if [[ "${yb_type}" == true ]]; then
    if [[ "${line_["type"]}" == *"value"* ]]; then
      yb::string::value_type "${line_["value"]}" "${line_["type"]}"
    fi
  fi

  # if a value query
  if [[ "${yb_value_query}" == true ]]; then
    yb::parse::print::is_value_query
    return 0
  fi

  # if '-A' is true
  if [[ "${yb_is_array}" == true ]]; then
    yb::parse:print::is_array
    return 0
  fi

  # if '-R' and "-F" are false, use colors
  if [[ "${yb_is_raw}" == false && "${yb_format}" == false ]]; then
    yb::parse::print::prepare_colors
  fi

  # print output
  yb::parse::print::output
}

########################################
# Print value queries
# Globals:
#   $yb_parent_type
#   $yb_query_pipe_result
#   $yb_value_option
#   $yb_query_pipe_first_line
#   $yb_show_line
#   $yb_query_result
#   $yb_silent_query
#   $yb_query_pipe_result
# Inherit:
#   ${line_[@]}
########################################
yb::parse::print::is_value_query(){
    # if value is a pipe value block
    if [[  "${yb_parent_type}" == *"key:pipe" ]]; then
      yb_query_pipe_result+="${line_["value"]}"
      # if current value is exactly the beginning of search value
      if [[ "${yb_value_option}" =~ "${yb_query_pipe_result}"* ]]; then
        # capture first line number of the pipe block
        if [[ -z "${yb_query_pipe_first_line}" ]]; then
          yb_query_pipe_first_line="${line_["line_number"]}"
        fi
        # when value is found completely
        if [[ "${yb_query_pipe_result}" == "${yb_value_option}" ]]; then
          if [[ "${yb_show_line}" == true ]]; then
            yb_query_result+="true{{T_${line_["type"]}}}{{N_${yb_query_pipe_first_line}_${line_["line_number"]}}}"
          else
            yb_query_result=true
          fi
          if [[ "${yb_silent_query}" == false ]]; then
            echo ${yb_query_result}
          fi
        fi
      else
        # reset temp values
        yb_query_pipe_result=""
        yb_query_pipe_first_line=""
      fi
    fi

    # if value is the same as the searched option (inline or list values)
    if [[ "${yb_value_option}" == "${line_["value"]}" || "${yb_value_option}" == "- ${line_["value"]}" ]]; then
      if [[ "${yb_show_line}" == true ]]; then
        yb_query_result+="true{{T_${line_["type"]}}}{{N_${line_["line_number"]}}} "
      else
        yb_query_result=true
      fi
      if [[ "${yb_silent_query}" == false ]]; then
        echo ${yb_query_result}
      fi
    fi
}

########################################
# Print array
# Globals:
#   $yb_one_line
#   $yb_array
#   $yb_value_type
# Inherit:
#   ${line_[@]}
########################################
yb::parse:print::is_array(){
  if [[ "${line_["type"]}" != "comment" && "${line_["type"]}" != "empty" ]]; then
    if [[ "${line_["type"]}" == *"key"* ]]; then
      if [[ "${line_["type"]}" == "list-key:value" ]]; then
        if [[ "${yb_one_line}" == false ]]; then
          yb_array+=("${line_["spacer"]}${line_["key"]}_ ${yb_value_type}${line_["value"]}${line_["outer"]}")
        else
          yb_array+=("${line_["spacer"]}${yb_value_type}${line_["value"]}${line_["outer"]}")
        fi
      else
        if [[ "${yb_one_line}" == false ]]; then
          yb_array+=("${line_["spacer"]}${line_["key"]}_${yb_value_type}${line_["value"]}${line_["outer"]}")
        else
          yb_array+=("${line_["spacer"]}${yb_value_type}${line_["value"]}${line_["outer"]}")
        fi
      fi
    else
      yb_array+=("${line_["spacer"]}${yb_value_type}${line_["value"]}${line_["outer"]}")
    fi
  fi
}

########################################
# Prepare colors for print
# Globals:
#   $yb_color_string
# Inherit:
#   ${line_[@]}
########################################
yb::parse::print::prepare_colors(){
  if [[ "${line_["type"]}" == "comment" ]]; then
    yb::string::set_color "${line_["value"]}" "${yb_grey}"
    line_["value"]="${yb_color_string}"
  elif [[ "${line_["type"]}" == *"key"* ]]; then
    yb::string::set_color "${line_["key"]}" "${yb_blue}"
    line_["key"]="${yb_color_string}"
    yb::string::set_color "${line_["prefix"]}" "${yb_blue}"
    line_["prefix"]="${yb_color_string}"
  fi
  if [[ "${line_["type"]}" == *"value"* ]]; then
    yb::string::color_type "${line_["value"]}"
    if [[ -n "${yb_value}" ]]; then
      line_["value"]="${yb_value}"
    fi
  fi
}

########################################
# Print final output
# Globals:
#   $yb_color_string
# Inherit:
#   ${line_[@]}
########################################
yb::parse::print::output(){
  local string=""
  # if a *key:value sequence
  if [[ "${yb_is_sequence}" == true && "${yb_one_line}" == true ]]; then
    if [[ "${line_["type"]}" == *"key:value" ]]; then
      if [[ "${yb_is_colored}" == true ]]; then
        echo -e "${line_["value"]}${line_["outer"]}"
      else
        echo "${line_["value"]}${line_["outer"]}"
      fi
      yb_one_line=false
      yb_is_print=false
    fi
  else
    if [[ "${line_["type"]}" == "comment" ]]; then
      string=$(echo -e "${line_["prefix"]}${yb_value_type}${line_["value"]}${line_["outer"]}")
      echo "${line_["spacer"]}"${string}
    else
      if [[ ${yb_is_colored} == true ]]; then
       string=$(echo -e "${line_["prefix"]}${line_["key"]}${line_["suffix"]}${yb_value_type}${line_["value"]}${line_["outer"]}")
      else
       string=$(echo -e "${line_["prefix"]}${line_["key"]}${line_["suffix"]}" && echo "${yb_value_type}${line_["value"]}${line_["outer"]}")
      fi
    if [[ "${line_["type"]}" == *"key:pipe" ]]; then
       echo "${spacer}"${string}
      # if a pipe value no color support
     elif [[ "${yb_parent_type}" == *"key:pipe" ]]; then
        string="${line_["prefix"]}${line_["key"]}${line_["suffix"]}${yb_value_type}${line_["value"]}${line_["outer"]}"
        echo "${line_["spacer"]}""${string}"
      else
        echo "${line_["spacer"]}"${string}
      fi
    fi
  fi
}

########################################
# Query file for an existing key
# Attributes:
#   $1 # mode (boolean verbose)
#   $2 # a key
# Globals:
#   yb_boolean_query
#   yb_line_number_query
#   yb_file
#   yb_is_empty
#   yb_query
#   yb_query_result
########################################
yb::query::search(){
  declare -a key=("${1-}")
  yb_key_step=0
  yb_query_search_result=""
  yb_query_result=""

  # set the query mode
  yb_boolean_query=true

  # prepare the search sequence and parse file
  yb::sequence "${key[@]}"
  yb::parse::yaml "${yb_file}"

  # if result contains true and not an addition scenario
  if [[  "${yb_query_result}" == *"true"* && "${yb_add}" == "false" ]]; then
    # output has been returned, exit
    exit 0
  fi

  if [[ -n "${yb_query_search_result}" ]]; then
    # has result
    yb_query_result=true
  elif [[ "${yb_is_empty}" == false ]]; then
    # has result but empty one
    if [[ -n "${yb_value_option}" ]]; then
      yb_query_result=false
    else
      yb_query_result=true
    fi
  elif [[ "${yb_query_search_result}" == "" ]]; then
    yb_query_result=false
  else
    # no result
    yb_query_result=false
  fi

  # reset flag
  yb_boolean_query=false
}

########################################
# Delete line in a file
# Attributes:
#   $1 # line to delete
# Globals:
#   yb_file
#   yb_YAML
########################################
yb::file::delete_line(){
  local line_to_delete="${1-}"
  local temp_file="${yb_file}.temp"
  local line_count=0

  # set IFS on newline
  IFS=$'\n'

  # loop through each line of the YAML object
  while IFS= read -r line; do

    line_count=$(( $line_count + 1 ))
    if [[ "${line_count}" == "${line_to_delete}" ]]; then
      continue
    else
      echo "${line}" >> "${temp_file}"
    fi

  done <<< "${yb_YAML}"

  mv "${temp_file}" "${yb_file}"

  # refresh yaml in cache
  yb::file::cache_yaml
}

########################################
# Query file for an existing value
# Attributes:
#   $1 # a key sequence
# Globals:
#   yb_key_step
#   yb_query_search_result
#   yb_query_result
#   yb_query_pipe_result
#   yb_value_query
#   yb_file
########################################
yb::query::search::values(){
  declare -a key=(${@-})  
  # reset flags and temp values
  yb_key_step=0
  yb_query_result=""
  yb_query_pipe_result=""

  # set the query mode
  yb_value_query=true

  # prepare the search sequence and parse file
  yb::sequence "${key[@]}"
  yb::parse::yaml "${yb_file}"

  # if a pipe result is retrieved
  if [[ -z "${yb_query_pipe_result}" ]]; then
    if [[ "${yb_query_pipe_result}" == "${yb_value_option}" ]]; then
      yb_query_result=true
    fi
  fi

  # if no results are found
  if [[ -z "${yb_query_result}" ]]; then
    yb_query_result=false
  fi

  # reset the query mode
  yb_value_query=false
}

########################################
# Query file for an existing key
# Attributes:
#   $1 # a key
# Globals:
#   yb_boolean_query
#   yb_line_number_query
#   yb_file
#   yb_is_empty
#   yb_query
#   yb_query_result
########################################
yb::query::search::keys_lines(){
  declare -a key=("${1-}")
  # reset temp values
  yb_query_lines_result=()
  yb_query_result=()
  yb_key_step=0

  # set mode flag
  yb_line_number_query=true

  # prepare the search sequence
  yb::sequence "${key[@]}"
  yb::parse::yaml "${yb_file}"

  # get the result
  yb_query_result="${yb_query_lines_result[@]}"

  # reset flag
  yb_line_number_query=false
}

########################################
# Query file for values coordinates
# Attributes:
#   $1 # a key
# Globals:
#   yb_boolean_query
#   yb_line_number_query
#   yb_file
#   yb_is_empty
#   yb_query
#   yb_query_result
########################################
yb::query::search::values_lines(){
  declare -a key=("${1-}")
  # empty global array before retrieving results
  yb_query_search_values_result=()
  yb_query_result=()
  yb_key_step=0

  # set mode flag
  yb_is_array=true
  yb_show_line_number=true
  yb_search_values_query=true

  # prepare the search sequence
  yb::sequence "${key[@]}"
  yb::parse::yaml "${yb_file}"

  # get the result
  yb_query_result="${yb_array[@]}"

  # reset flag
  yb_is_array=false
}

########################################
# Add key(s) in a file
# Attributes:
#   $1 # line number
#   $2 # level
#   $3 # index
# Globals:
#   yb_key
#   yb_key_length
########################################
yb::add::keys::to_file(){
  local parent_line_number="${1-}"
  local parent_level="${2-}"
  local spacing="\ \ "
  local spacer
  local target_line_number
  local counter=0

  # find the correct line depending on previous additions
  target_line_number=$(( $parent_line_number + $yb_added_lines ))

  # referesh keys referential
  yb::sequence::key_to_array "${yb_key_option}"

  for (( aif = $parent_level + 1; aif < $yb_key_length; aif++ )); do 
    spacer=""
    for (( sp = 0; sp < $parent_level + 1; sp++ )); do
      spacer+="${spacing}"
    done

    # if a pipe key
    if [[ "${yb_keys[${aif}]}" == *"|" ]]; then
      child_key="${spacer}${yb_keys[${aif}]%?}:"
      if [[ "${aif}" -eq $(( $yb_key_length - 1 )) ]]; then
       child_key="${spacer}${yb_keys[${aif}]%?}: |"
      fi
    else 
      child_key="${spacer}${yb_keys[${aif}]}:"
    fi

    # write in file
    sed -i "${target_line_number} a ${child_key}" "${yb_file}"
    # increment levels and line numbers for next iteration
    parent_level=$(( $parent_level + 1 ))
    target_line_number=$(( $target_line_number + 1 ))
    # increment the global added lines
    counter=$(( $counter + 1 ))
  done
  yb_added_lines=$(( $yb_added_lines + $counter ))
}

#########################################
# # Add path child keys
# # Attributes:
# #   $@ # an array of key coordinates (level, line number)
# ########################################
yb::add::child_keys::to_file(){
    declare -a keys_anchors=(${@})
    local parent_level
    local parent_line

    for anchor in "${keys_anchors[@]}"; do
      parent_level="${anchor%%_N*}"
      parent_level="${parent_level#*L}"
      parent_line="${anchor#*N}"

      yb::add::keys::to_file "${parent_line}" "${parent_level}"
    done
}

########################################
# Add new key(s) in a file
# Globals:
#   yb_key
#   yb_key_length
########################################
yb::add::new_keys::to_file(){
  local level=0
  local spacing="  "
  local spacer
  # local target_line_number
  local counter=0

  # referesh keys referential
  yb::sequence::key_to_array "${yb_key_option}"

  for (( aif = 0 ; aif < $yb_key_length; aif++ )); do 
    spacer=""
    for (( sp = 0; sp < level; sp++ )); do
      spacer+="${spacing}"
    done

    # if a pipe key
    if [[ "${yb_keys[${aif}]}" == *"|" ]]; then
      child_key="${spacer}${yb_keys[${aif}]%?}:"
      if [[ "${aif}" -eq $(( $yb_key_length - 1 )) ]]; then
       child_key="${spacer}${yb_keys[${aif}]%?}: |"
      fi
    else 
      child_key="${spacer}${yb_keys[${aif}]}:"
    fi

    # write in file on the last line
    sed -i "\$s/\$/ \n$child_key/" "${yb_file}"
    # increment levels and line numbers for next iteration
    level=$(( $level + 1 ))
  done
}

########################################
# Build the key coordinates
# Globals:
#   yb_key
#   yb_key_length
#   yb_coordinates
########################################
yb::add::manage::keys(){
  local has_key
  local sequence_length="${yb_key_length}"
  local search_key=""
  local counter=$sequence_length  
  declare -a keys=("${yb_keys[@]}")
  declare -a coordinates
  declare -a reverse_array

  for (( rk = ${#keys[@]} - 1; rk >= 0; rk-- )); do
      reverse_array+=("${keys[rk]}")
  done  

  for (( s = 0; s < $sequence_length; s++ )); do
    search_key=""

    for (( rs = 0; rs < $counter; rs++ )); do
      search_key+=".${reverse_array[$rs]}"
    done  

    # strip first "." character
    search_key="${search_key:1}"

    yb::query::search::keys_lines "${search_key}"
    # get result
    has_key=("${yb_query_result}")

    # this gives a behavior where only 
    # the first level of parents are targeted
    if [[ -n "${has_key}" ]]; then
      break;
    fi
    counter=$(( $counter - 1 ))
  done

  if [[ -z "${has_key}" ]]; then
    yb::add::new_keys::to_file
  else
    yb::add::child_keys::to_file "${has_key}"
  fi
}

########################################
# Add value(s) to file
# Attributes:
#   $1 # parent keys
# Globals:
#   yb_value_option
########################################
yb::add::values::to_file(){
  declare -a parents=(${1-})
  local value_type

  # set mode
  if [[ "${yb_value_option}" == "- "* ]]; then
    value_type="list"
  elif [[ "${yb_value_option}" == "|"* ]]; then
    value_type="pipe"
  else 
    value_type="inline"
  fi

  if [[ "${value_type}" == "inline" ]]; then
    yb::add::values::to_file::inline "${parents[@]}"
  elif [[ "${value_type}" == "list" ]]; then
    yb::add::values::to_file::list "${parents[@]}"
  elif [[ "${value_type}" == "pipe" ]]; then
    yb::add::values::to_file::pipe "${parents[@]}"
  fi
}

########################################
# Add inline value(s) to file
# Attributes:
#   $1 # parent keys
# Globals:
#   $yb_file
#   $yb_value_option
########################################
yb::add::values::to_file::inline(){  
  declare -a parents=("${@}")
  local key_line
  local parent_key_value
  local inline_value

  # iterate over parent keys
  for key in "${parents[@]}"; do
    key_line="${key##*_N}"
    # get the existing content from the line
    parent_key_value=$(sed -n "${key_line}p" "$yb_file")
    # prepare line value
    # todo : explore use of echo here
    inline_value=$(echo "${parent_key_value} ${yb_value_option}")
    # write key:value on the same line
    sed -i "${key_line}c\\$inline_value" "$yb_file"
  done
}

########################################
# Add list value(s) to file
# Attributes:
#   $1 # parent keys
# Globals:
#   $yb_file
#   $yb_value_option
#   $yb_trimmed
########################################
yb::add::values::to_file::list(){  
  declare -a parents=("${@}")
  local string
  local delimeter
  local condition
  local counter
  local key_line
  local clean_value
  local key_level
  local spacer
  local clean_array_length
  local spacing="\ \ "
  declare -a value_array
  declare -a clean_value_array

  # add a space before the string to cope with delimeter
  yb_value_option=" ${yb_value_option}"
  # declare parsing values
  string="${yb_value_option}"
  delimiter=' - '
  condition=$string$delimiter
  # check for delimeter in string
  while [[ $condition ]]; do
      value_array+=( "${condition%%"$delimiter"*}" );
      condition=${condition#*"$delimiter"};
  done;
  # iterate over values to clean them
  for raw_value in "${value_array[@]}"; do
    if [[ -n "${raw_value}" ]]; then
      _trim_space ${raw_value}
      raw_value="${yb_trimmed//\\/\\\\}"
      clean_value_array+=("${raw_value}")
    fi
  done
  # iterate over parent keys
  counter=0
  for key in "${parents[@]}"; do
    key_line="${key##*_N}"
    key_level="${key%%_N*}"
    key_level="${key_level##L}"
    # build spacer
    spacer=""
    for (( sp = 0; sp < $key_level + 1; sp++ )); do
      spacer+="${spacing}"
    done
    clean_array_length=${#clean_value_array[@]}

    for (( cv = clean_array_length - 1; cv >= 0 ; cv-- )); do
      key_line=$(( $key_line + $counter ))
      clean_value="${spacer}- ${clean_value_array[$cv]}"
      sed -i "${key_line} a ${clean_value}" "${yb_file}"
    done

    counter=$(( $counter + 1 ))
  done
}

########################################
# Add pipe value(s) to file
# Attributes:
#   $1 # parent keys
# Globals:
#   $yb_file
#   $yb_value_option
#   $yb_pipe_delimeter
#   $yb_trimmed
########################################
yb::add::values::to_file::pipe(){  
  declare -a parents=("${@}")
  local string
  local delimeter
  local condition
  local key_line
  local key_level
  local clean_value
  local clean_array_length
  local spacer
  local spacing="\ \ "
  declare -a value_array
  declare -a clean_value_array

  # add a space before the string to cope with delimeter
  yb_value_option=" ${yb_value_option}"
  # declare parsing values
  string="${yb_value_option}"
  delimiter=" ${yb_pipe_delimeter} "
  condition=$string$delimiter
  # check for delimeter in string
  while [[ $condition ]]; do
      value_array+=( "${condition%%"$delimiter"*}" );
      condition=${condition#*"$delimiter"};
  done;

  # iterate over values to clean them
  for raw_value in "${value_array[@]}"; do
    if [[ -n "${raw_value}" ]]; then
      raw_value="${raw_value//\\/\\\\}"
      clean_value_array+=("${raw_value}")
    fi
  done

  # iterate over parent keys
  for key in "${parents[@]}"; do
    key_line="${key##*_N}"
    key_level="${key%%_N*}"
    key_level="${key_level##L}"
    # build spacer
    spacer=""
    for (( sp = 0; sp < $key_level + 1; sp++ )); do
      spacer+="${spacing}"
    done
    clean_array_length=${#clean_value_array[@]}
    for (( cv = clean_array_length - 1; cv >= 0 ; cv-- )); do
      clean_value="${spacer}${clean_value_array[$cv]}"
      sed -i "${key_line} a ${clean_value}" "${yb_file}"
    done
  done
}

########################################
# Manage value addition
# Globals:
#   $yb_keys
#   $yb_key_length
#   $yb_coordinates
#   $yb_key_option
#   $yb_query_result
########################################
yb::add::manage::values(){
  local has_key
  declare -a keys=("${yb_keys[@]}")
  local sequence_length="${yb_key_length}"
  local counter=$sequence_length

  # query for lines coordinates
  yb::query::search::keys_lines "${yb_key_option}"

  # get result
  has_key=("${yb_query_result}")

  # add values in file
  yb::add::values::to_file "${has_key}"
}

########################################
# Add key(s) and/or value(s)
# Globals:
#   $yb_file
#   $yb_query
#   $yb_key_option
#   $yb_value_option
########################################
yb::add(){
  yb::query::search "${yb_key_option}"

  if [[ "${yb_query}" == false ]]; then
    yb::add::manage::keys "${yb_key_option}"
    yb::file::cache_yaml
  fi

  if [[ -n "${yb_value_option-}" ]]; then
    yb::add::manage::values "${yb_value_option}"
  fi

  # as sed tends to add trailing whitespaces remove them
  sed -i 's/[[:space:]]*$//'  "${yb_file}"
}

########################################
# Remove key(s) and/or value(s)
# Globals:
#   yb_key_option
#   yb_query_result
#   yb_file
########################################
yb::remove(){
  declare -a parent_lines=()
  declare -a child_lines=()

  yb_query_result=()
  declare -a child_array
  declare -a remove_lines
  local next_line
  local remove_line
  local line_counter=0

  # get lines for parents and children
  yb::query::search::keys_lines "${yb_key_option}"
  parent_lines=(${yb_query_result})
  yb::query::search::values_lines "${yb_key_option}"
  child_lines=(${yb_query_result})

  if [[ -z "${parent_lines[@]}" && -z "${child_lines[@]}" ]]; then
    # nothing to remove
    return 0
  fi

  # prepare child lines numbers
  if [[ -n "${child_lines[@]}" ]]; then
    for child in "${child_lines[@]}"; do
      child="${child##*'{{'}"
      child="${child%%'}}'}"
      child_array+=("${child}")
    done
  fi

  # prepare overall line numbers
  for parent in "${parent_lines[@]}"; do
    parent="${parent##*_N}"
    next_line=$(( $parent + 1 ))
    remove_lines+=("${parent}")
    if [[ -n "${child_array[@]}" ]]; then
      for (( ch = 0; ch < "${#child_array[@]}"; ch++ )); do
        # note: this may not work for files with 99+ lines
        if [[ "${child_array[*]}" =~ "${next_line}" ]]; then
          remove_lines+=("${next_line}")
          next_line=$(( $next_line + 1 ))
        else
          # if lines are not consecutive, break
          break;
        fi
      done
    fi
  done

  # iteratevely delete line numbers and adjust line number accordingly
  for (( li = 0; li < "${#remove_lines[@]}"; li++ )); do
    remove_line="${remove_lines[${li}]}"
    remove_line=$(( $remove_line - $line_counter ))
    # yb::file::delete_line "${remove_line}"
    sed -i "${remove_line}d" "${yb_file}"
    line_counter=$(( $line_counter + 1 ))
  done
}

########################################
# Remove a value
# Globals:
#   yb_key_option
#   yb_query_result
#   yb_file
########################################
yb::remove::values(){
  declare -a parent_lines
  declare -a child_lines
  declare -a child_array
  declare -a remove_lines
  local next_line
  local remove_line
  local line_counter=0
  local first_line_number
  local line_number
  local lines_to_delete
  local line_type
  local spacing="\ \ "
  local spacer=""
  local last_key_index
  local last_key

  yb_show_line=true
  yb_silent_query=true
  local pipe_query=""

  # check if a pipe value
  if [[ "${yb_key_option: -1}" == "|" ]]; then
    pipe_query=true
  fi

  yb::query::search::values "${yb_key_option}"
  result=(${yb_query_result})

  if [[ "${result}" == false ]]; then
    return 0
  fi

  if [[ "${pipe_query}" == true ]]; then
    yb::remove::values::pipe "${result[@]}"
  else
    yb::remove::values::inline_and_list "${result[@]}"
  fi

  # reset flag
  yb_show_line=false
  yb_silent_query=false
}

########################################
# Remove pipe value(s) from file
# Attributes:
#   $1 # parent keys
########################################
yb::remove::values::pipe(){
  declare -a result=(${@})
  local line_type
  local line_number
  local line_counter=0
  local lines_to_delete
  local first_line_number

  for (( rs = 0; rs < "${#result[@]}" ; rs++ )); do
    line_type="${result[$rs]##*'{{T_'}"
    line_type="${line_type%%'}}{{N_'*}"
    line_number="${result[$rs]##*'{{N_'}"
    line_number="${line_number%%'}}'}"
    first_line_number="${line_number%%'_'*}"
    line_number="${line_number##*'_'}"  
    # adjust the line numbers in regards to previous modifications
    first_line_number=$(( $first_line_number - $line_counter ))
    line_number=$(( $line_number - $line_counter )) 

    lines_to_delete="${line_number}"
    for (( ld = $first_line_number; ld <= $lines_to_delete; ld++ )); do
      sed -i "${line_number}d" "${yb_file}"
      line_number=$(( $line_number - 1 ))
      line_counter=$(( $line_counter + 1 ))
    done
  done

}

########################################
# Remove inline and list value(s) from file
# Attributes:
#   $1 # parent keys
# Globals:
#   yb_keys
#   yb_file
########################################
yb::remove::values::inline_and_list(){
  declare -a result=(${@})
  local line_type
  local line_number
  local line_counter=0
  local lines_to_delete
  local first_line_number
  local last_key
  local last_key_index
  local spacing="\ \ "
  local spacer=""

  for (( rs = 0; rs < "${#result[@]}" ; rs++ )); do
    line_type="${result[$rs]##*'{{T_'}"
    line_type="${line_type%%'}}{{N_'*}"
    line_number="${result[$rs]##*'{{N_'}"
    line_number="${line_number%%'}}'}"
    # adjust the line number in regards to previous modifications
    line_number=$(( $line_number - $line_counter ))

    if [[ "${line_type}" == *"key:value" ]]; then
      sed -i "${line_number}d" "${yb_file}"
      line_number=$(( $line_number - 1 ))
      # create spacer
      for (( sp = 0; sp < $yb_key_length - 1; sp++ )); do
        spacer+="${spacing}"
      done
      # find key
      last_key_index=$(( $yb_key_length - 1 ))
      last_key="${yb_keys[$last_key_index]}"
      if [[ "${line_type}" == "key:value" ]]; then
        last_key="${spacer}${last_key}:"
      elif [[  "${line_type}" == "list-key:value" ]]; then
        last_key="${spacer}${last_key}:"
      fi
      # re-add the key
      sed -i "${line_number} a ${last_key}" "${yb_file}"
      # clean spacer
      spacer=""
    else
      sed -i "${line_number}d" "${yb_file}"
      # increment line count
      line_counter=$(( $line_counter + 1 ))
    fi
  done
}

########################################
# Build the spacer that comes before a key or value
# Globals:
#   $yb_format
#   $yb_spacing
#   $yb_set_level
#   $yb_spacer
# Inherit:
#   ${line_[@]}
########################################
yb::string::build_spacer(){
  local level="${line_["level"]}"
  local style=""
  local separator=""
  local spacer=""

  # set the correct starting level
  if [[ ${yb_is_sequence} == true ]]; then
    level=$(( $level - 1 ))
  else 
    level=$(( $level + 1 ))
  fi

  # switch the separator type
  if [[  "${yb_format}" == true ]]; then
    style="."
    separator="${style}"
    level=$(( $level + 1 ))
  else
    style=" "
    # set the separator length based one
    for (( i = 0; i < $yb_spacing; i++ )); do
      separator+="${style}"
    done
  fi

  yb::string::set_level "${level}"

  level="${yb_set_level}"

  for (( i = 0; i < $level; i++ )); do
    spacer+="${separator}"
  done
  
  if [[ "${line_["type"]}" == *"value"* && "${yb_format}" == true ]]; then
    spacer+="${yb_previous_parent}_"
  fi

  line_["spacer"]="${spacer}"
}

########################################
# Set the correct level depending on cli options
# Globals:
#   yb_is_sequence
#   yb_depth
#   yb_is_array
#   yb_format
#   yb_key_base_level
# Attributes:
#   $1 # current $level
########################################
yb::string::set_level(){
  local level="${1-}"

  # set the correct level number
  if [[ ${yb_is_sequence} == false ]]; then
    level=$(( $level - 1 ))
  elif [[ ${yb_depth} == true ]]; then
    level=$(( $level + 1 ))
  elif [[ "${yb_is_array}" == true && "${yb_format}" == false ]]; then
    level=0
  elif [[ "${yb_is_sequence}" == true ]]; then
    local base_level="${yb_key_base_level}"
    level=$(( $level - $base_level ))
  fi

  # assign the resulting value to the global
  yb_set_level="${level}"
}

########################################
# Build the outer that comes after a key or value
# Globals:
#   $yb_show_line
#   $yb_show_level
#   $yb_show_line_number
#   $yb_outer
# Inherit:
#   ${line_[@]}
########################################
yb::string::build_outer(){
  local outer=""
  local line_spacer="{{line}}"
  local line_level_spacer="{{${line_["level"]}}}"
  local line_number_spacer="{{${line_["line_number"]}}}"

  # add an outer {{line}} for each line
  if [[ "${yb_show_line}" == true ]]; then
    outer+="${line_spacer}"
  fi
  # add an outer {{$level}} for each line
  if [[ "${yb_show_level}" == true ]]; then
    outer+="${line_level_spacer}"
  fi
  # add an outer {{$line_number}} for each line
  if [[ "${yb_show_line_number}" == true ]]; then
    outer+="${line_number_spacer}"
  fi
  line_["outer"]="${outer}"
  # yb_outer="${outer}"
}

########################################
# Check for a value type
# Attributes:
#   $1 # a value
#   $2 # a value type
# Globals:
#   $yb_value_type
########################################
yb::string::value_type(){
  local value="${1-}"
  local type="${1-}"
  local boolean_regex='^(?i)true$'
  local float_regex='^[0-9.]+$'
  yb_value_type=""

  # see https://yaml.org/spec/1.2.2/#1011-tags
  # partial support, missing keys types
  if [[ "${type}" == "comment" ]]; then
    continue
  elif [[ "${value}" =~ ^(true|TRUE|false|FALSE)$ ]]; then
    yb_value_type="!! bool "
  elif [[ "${value}" =~ ^[0-9]+$ ]]; then
    yb_value_type="!! int "
  elif [[ "${value}" =~ ^(null|NULL)$ ]]; then
    yb_value_type="!! null "
  # regex variable need to be unquoted
  elif [[ "${value}" =~ ${float_regex} ]]; then
    yb_value_type="!! float "
  elif [[ -n "${value}" ]]; then
    yb_value_type="!! str "
  fi
}

########################################
# Check for a value type
# Attributes:
#   $1 # a value
########################################
yb::string::color_type(){
  local value="${1-}"

  if [[ "${yb_value_type}" == "!! bool " ]]; then
    yb::string::set_color "${value}" "${yb_red}"
    yb_value="${yb_color_string}"
    yb_is_colored=true
  elif [[ "${yb_value_type}" == "!! int " || "${yb_value_type}" == "!! float " ]]; then
    yb::string::set_color "${value}" "${yb_orange}"
    yb_value="${yb_color_string}"
    yb_is_colored=true

  elif [[ "${yb_value_type}" == "!! null " ]]; then
    yb::string::set_color "${value}" "${yb_italic}"
    yb_value="${yb_color_string}"
    yb_is_colored=true
  fi
}

########################################
# Trim leading and trailing spaces
# Attributes:
#   $1 # string
########################################
_trim_space(){
  local string="${@-}"

  string="${string#"${string%%[![:space:]]*}"}"
  string="${string%"${string##*[![:space:]]}"}"

  yb_trimmed="${string}"
}

########################################
# Trim a leading hyphen and one space
# Attributes:
#   $1 # string
########################################
_trim_hyphen(){
  local string="${@-}"

  # string="${string##*- }"
  string="${string#- }"

  yb_trimmed="${string}"
}

########################################
# Add some color tags to a string
# Attributes:
#   $1 # string
#   $2 # an ANSI format color
########################################
yb::string::set_color(){
  local text="${1-}"
  local color="${2-}"
  yb_color_string="${color}${text}\033[0m"
}

########################################
# Print a debug message
# Attributes:
#   $@ # some message
########################################
_debug(){
  local message="${@}"
  echo "${BASH_LINENO} : ${message}"
}

########################################
# Prepare globals for sequence search
# Attributes:
#   $1 # a yaml key
########################################
yb::sequence(){
  local key=${@:-"${yb_key_option}"}

  # set flags
  yb_is_sequence=true
  yb_retrieve=false

  yb::sequence::key_to_array "${key}"
}

########################################
# Lock YAML file
# Attributes:
#   $1 # a yaml file
########################################
yb::file::lock(){
  local file="${1}"
  local path="${file%/*}"
  local filename="${file##*/}"

  if [[ "${file}" == */* ]]; then
    path="${path}/.${filename}.yb.lock"
  else
    path=".${file}.yb.lock"
  fi

  if [[ -f "${path}" ]]; then
    echo "File is currently being processed with yb."
    exit 1
  else
    touch "${path}"
  fi
}

########################################
# Unlock YAML file
# Attributes:
#   $1 # a yaml file
########################################
yb::file::unlock(){
  local file="${1}"
  local path="${file%/*}"
  local filename="${file##*/}"

  if [[ "${file}" == */* ]]; then
    path="${path}/.${filename}.yb.lock"
  else
    path=".${file}.yb.lock"
  fi

  rm "${path}"
}

########################################
# Transform original key option into an array
# Attributes:
#   $1 # a yaml key
# Globals:
#   yb_key_option
#   yb_key_length
# Output:
#   yb_keys[@]
########################################
yb::sequence::key_to_array(){
  local keys="${1:-"${yb_key_option}"}"
  local local_index
  declare -a local_array
  yb_keys=()

  # replace space with anti-backslash
  keys="${keys// /\\}"
  # replace points with spaces
  keys="${keys//./ }"
  # transform the string in an array
  keys=(${keys})

  yb_key_length="${#keys[@]}"

  for (( yk = 0; yk < $yb_key_length; yk++ )); do
    key="${keys[$yk]}"
      if [[ "${key}" == *\\* ]]; then
        # replace anti-backslash with space
        key="${key//\\/ }"
      fi
      yb_keys[$yk]="${key}"
  done

  if [[ -z "${yb_original_key_length}" ]]; then
    yb_original_key_length="${yb_key_length}"
  fi
}

########################################
# Cache yaml file into a global variable
# Attributes:
#   $1 # a yaml file path
########################################
yb::file::cache_yaml(){
  local file="${1:-${yb_file}}"
  yb_YAML=$(<"${file}")
}

########################################
# Dump array, print an error and exit
########################################
yb::core::exit_dump() {
  echo "${yb_array[@]}"
  _error "${@-}"
  _exit
}

########################################
# Print an error and exit
########################################
yb::core::exit() {
  # unlock YAML file
  yb::file::unlock "${yb_file}"
  # exit
  exit 0
}

########################################
# Print an error message in STDERR
########################################
yb::core::error() {
  echo "${FUNCNAME[1]} :: [$(date +'%Y-%m-%dT%H:%M:%S%z')] :: ${@-}" 2>&1
}

########################################
# Parse script options
# Globals:
#   yb_line_number_query
########################################
yb::main::start(){

  yb::file::cache_yaml "${yb_file}"

  if [[ "${yb_query}" == true ]]; then
    # if looking for a value
    if [[ -n "${yb_value_option}" ]]; then
      yb::query::search::values "${yb_key_option}"
      if [[ "${yb_query_result}" == false ]]; then
        echo "${yb_query_result}"
      fi
    else
      yb::query::search "${yb_key_option}"
      echo "${yb_query_result}"
    fi
  elif [[ "${yb_add}" == true ]]; then
    yb::add
  elif [[ "${yb_remove}" == true ]]; then
    if [[ -n "${yb_value_option}" ]]; then
      yb::remove::values
    else
      yb::remove
    fi
  elif [[ -n "${yb_key_option}" ]]; then
    yb::sequence
    yb::parse::yaml "${yb_file}"
  elif [[ -z "${yb_key_option}" ]]; then
    yb::parse::yaml "${yb_file}"
  fi

  if [[ "${yb_is_array}" == true ]]; then
    echo "${yb_array[@]}"
  fi
}

########################################
# Initialize the cli
# Attributes:
#   $@ # script user options
########################################
yb::main::cli(){
  while getopts "aAdf:Fk:lLnqrRTv:" arg; do
    case $arg in
      a)
        yb_add=true
        ;;
      A)
        yb_is_array=true
        ;;
      d)
        yb_depth=true
        ;;
      f)
        yb_file="${OPTARG}"
        ;;
      F)
        yb_format=true
        ;;
      k)
        yb_key_option="${OPTARG}"
        ;;
      l)
        yb_show_line=true
        ;;
      L)
        yb_show_level=true
        ;;
      q)
        yb_query=true
        ;;
      n)
        yb_show_line_number=true
        ;;
      r)
        yb_remove=true
        ;;
      R)
        yb_is_raw=true
        ;;
      T)
        yb_type=true
        ;;
      v)
        yb_value_option="${OPTARG}"
        ;;
    esac
  done
  # if no options were provided
  if [[ "${OPTIND}" -eq 1 ]]; then
    # if arguments were provided
    if [[ "${#}" -gt 0 ]]; then
      yb_file="${1-}"
      yb_key_option="${2-}"
    else
      echo "No parameters provided"
      exit
    fi
  fi
}

########################################
# Main function
# Attributes:
#   $@ # script user options
########################################
yb::main(){
  yb::main::globals
  yb::main::cli "${@}"

  # check for the existence of the parameter file
  if ! [[ -f "${yb_file}" ]]; then
    echo "A YAML file needs to be provided through the '-f' option."
    exit
  fi

  # trap the exit function
  trap yb::core::exit_dump SIGINT
  trap yb::core::exit EXIT

  # lock YAML file
  yb::file::lock "${yb_file}"

  # parse cli options and launch methods
  yb::main::start
}

# Launch main function
yb::main "${@}"
# Unset the eu flag
set +eu