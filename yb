#!/bin/bash
#---------------------------------------
# yb | yaml bash parser
#---------------------------------------

# Set the eu flag
set -eu

########################################
# Declare globals
# Attributes:
#   $@ # script user options
########################################
_globals(){
  declare -g yb_spacing=2
  declare -g yb_grey="\033[0;30m"
  declare -g yb_blue="\033[1;36m"
  declare -g yb_orange="\033[1;33m"
  declare -g yb_depth=false
  declare -g yb_format=false
  declare -g yb_is_array=false
  declare -g yb_is_raw=false
  declare -g yb_show_level=false
  declare -g yb_show_line=false
  declare -g yb_show_line_number=false
  declare -g yb_is_sequence=false
  declare -g yb_key_length=0
  declare -g yb_key_step=0
  declare -g yb_key_base_level=0
  declare -g yb_retrieve=false
  declare -g yb_is_retrieved=false
  declare -g yb_is_print=false
  declare -g yb_one_line=false
  declare -g yb_previous_parent=""
  declare -ga yb_array
}

########################################
# Parse a yaml file
# Attributes:
#   $1 # /path/to/a/yaml/file 
########################################
_parse_yaml() {
  local file="${1-}"
  local comment
  local yaml
  local separator
  local line
  local spaces
  local level
  local type
  local key=""
  local value=""
  local parent=""
  local line_number=0
  local prefix
  local suffix

  # global associative array
  declare -A line_structure

  # Read the YAML file
  yaml=$(<"${file}")

  # Set whitespace as field separator
  IFS=$' \t\n'

  # Loop through each line of the YAML file
  while IFS= read -r line; do
    # keep track of current line number
    ((line_number += 1))

    # reset variables values
    key=""
    value=""
    suffix=""
    prefix=""

    # Count the leading spaces to determine the indentation level
    spaces="${line%%[^[:space:]]*}"
    level="${#spaces}"
    level="$(( level / yb_spacing + 1 ))"

    # Remove the leading and trailing spaces
    line=$(_trim_space "${line}")

    # Check the line type
    if [[ -z "${line}" ]]; then 
      type="empty"
    elif [[ "${line}" == "#"* ]]; then
      type="comment"
      value="${line}"
    elif [[ "${line}" == *":" && "${line}" != "-"*":"* ]]; then
      type="key"
      key="${line%%:*}"
      parent="${key}"
      yb_previous_parent="${key}"
      suffix=": "
    elif [[ "${line}" == *": "* && ${line} != "- "* ]]; then
      type="key:value"
      key="${line%%:*}"
      value="${line#*:}"
      key=$(_trim_space "${key}")
      value=$(_trim_space "${value}")
      parent="${key}"
      suffix=": "
    elif [[ "${line}" == "- "*": "* ]]; then
      type="list-key:value"
      key=$(_trim_space "${line}")
      key=$(_trim_hyphen "${key}")
      key="${key%%:*}"
      value="${line#*:}"
      value=$(_trim_space "${value}")
      prefix="- "
      suffix=": "
      # in this case, the parent is on the previous line
      parent="${yb_previous_parent}"
    elif [[ "${line}" == "-"*":" ]]; then
      # if [[ ${level} -eq 0 ]]; then
        type="list-key"
        # Trim leading space and list hyphen
        key=$(_trim_space "${line}")
        key=$(_trim_hyphen "${line}")
        key="${key%%:*}"
        prefix="- "
        parent="${key}"
        yb_previous_parent="${key}"
      elif [[ "${line}" == "-"* ]]; then
        type="list-value"
        # Trim leading space and list hyphen
        value=$(_trim_space "${line}")
        value=$(_trim_hyphen "${line}")
        prefix="- "
    else
      type="other"
      value="${line}"
    fi

    # populate the associative array
    line_structure=(
      [type]="${type}"
      [level]="${level}"
      [line_number]="${line_number}"
      [key]="${key-}"
      [value]="${value-}"
      [parent]="${parent-}"
      [prefix]="${prefix-}"
      [suffix]="${suffix-}"
    )

    # send the reference
    _manage line_structure

  done <<< "${yaml}"

  # Reset IFS to default value
  unset IFS
}

########################################
# Manage lines structures depending on action
# Attributes:
#   $1 # an associative array reference
########################################
_manage(){
  local -n line_manage="$1"
  # build $spacer and $outer
  line_manage["spacer"]=$(_spacer "${line_manage["level"]}" "${line_manage["type"]}" "${line_manage["parent"]}")
  line_manage["outer"]=$(_outer "${line_manage["level"]}" "${line_manage["line_number"]}")
  # if a sequence, search if the path is correct
  if [[ "${yb_is_sequence}" == true ]]; then
     _search "${line_manage["key"]}" "${line_manage["level"]}" "${line_manage["type"]}"
  fi

  # if correct path, or if regular print, print
  if [[ "${yb_is_print}" == true ]]; then
    _print line_manage
  fi

  if [[ "${yb_is_sequence}" == false ]]; then
    _print line_manage
  fi
}

########################################
# Search the correct key path
# Attributes:
#   $1 # current $key
#   $2 # current $level
#   $3 # current $type
########################################
_search(){
  local key="${1-}"
  local level="${2-}"
  local type="${3-}"

  # if sequence hasn't been found yet
  if [[ "${yb_retrieve}" == false ]]; then
    if [[ "${key}" == "${yb_key["${yb_key_step}"]}" ]]; then
      # if sequence is found
      ((yb_key_step += 1))
      # if value is on a sub level, retrieve it
      if [[ "${yb_key_step}" -eq "${yb_key_length}" ]]; then
        yb_retrieve=true
        yb_key_base_level="${level}"
        # if value is *key:value, retrieve only once
        if [[ "${type}" == "key:value" ]]; then
          # search result is only one line
          yb_one_line=true
          # sequence is over, reset flags
          yb_key_step=0
          # yb_is_retrieved=false
          yb_retrieve=false
          # send a true signal to print the current line
          yb_is_print=true
        fi
      fi
    fi
  elif [[ "${yb_retrieve}" == true && "${level}" -gt "${yb_key_base_level}" ]]; then
    # send a true signal to print the current line
    yb_one_line=false
    yb_is_print=true
  else
    yb_one_line=false
    yb_is_print=false
    # if the level is lower or equal the key level
    # sequence is over, reset flags
    yb_key_step=0
    # yb_is_retrieved=false
    yb_retrieve=false
  fi
}

########################################
# Build the spacer that comes before a key or value
# Attributes:
#   $1 # current $level
#   $2 # current $type
########################################
_spacer(){
  local level=${1-}
  local type=${2-}
  local parent=${3-}
  local style=""
  local separator=""
  local spacer=""

  # switch the separator type
  if [[  "${yb_format}" == true ]]; then
    style="."
    level=$(( $level ))
    separator="${style}"
  else
    style=" "
    level=$(( $level - 1 ))
    # set the separator length based one
    for (( i = 0; i < $yb_spacing; i++ )); do
      separator+="${style}"
    done
  fi

  level=$(set_level "${level}")

  for (( i = 0; i < $level; i++ )); do
    spacer+="${separator}"
  done
    
  if [[ "${type}" == *"value"* && "${yb_format}" == true ]]; then
      spacer+="${parent}_"
  fi

  echo "${spacer}"
}

########################################
# Set the correct level depending on -options
# Attributes:
#   $1 # current $level
########################################
set_level(){
  local level="${1-}"

  # set the correct level number
  if [[ ${yb_is_sequence} == false ]]; then
    level=$(( $level -1 ))
    echo "${level}"
  elif [[ ${yb_depth} == true ]]; then
    echo "${level}"
  elif [[ "${yb_is_array}" == true && "${yb_format}" == false ]]; then
    level=0
    echo "${level}"
  elif [[ "${yb_is_sequence}" == true ]]; then
    local base_level="${yb_key_base_level}"
    level=$(( $level - $base_level ))
    echo "${level}"
  fi
}

########################################
# Build the outer that comes after a key or value
# Attributes:
#   $1 # current $level
#   $2 # current $type
########################################
_outer(){
  local outer=""
  local line_spacer="{{line}}"
  local line_level_spacer="{{${1-}}}"
  local line_number_spacer="{{${2-}}}"

  # add an outer {{line}} for each line
  if [[ "${yb_show_line}" == true ]]; then
    outer+="${line_spacer}"
  fi
  # add an outer {{$level}} for each line
  if [[ "${yb_show_level}" == true ]]; then
    outer+="${line_level_spacer}"
  fi
  # add an outer {{$line_number}} for each line
  if [[ "${yb_show_line_number}" == true ]]; then
    outer+="${line_number_spacer}"
  fi
  echo "${outer}"
}

########################################
# Print to terminal
# Attributes:
#   $1 # an associative array reference
########################################
_print(){
  local -n line_print="$1"
  local level=${line_print["level"]}
  local type="${line_print["type"]}"
  local key="${line_print["key"]}"
  local value="${line_print["value"]}"
  local prefix="${line_print["prefix"]}"
  local suffix="${line_print["suffix"]}"
  local line_number="${line_print["line_number"]}"
  local spacer="${line_print["spacer"]}"
  local outer="${line_print["outer"]}"
  local string=""
  local has_colors=""

  if [[ "${yb_is_array}" == true ]]; then
    if [[ "${type}" != "comment" && "${type}" != "empty" ]]; then
      if [[ "${type}" == *"key"* ]]; then
        if [[ "${type}" == "list-key:value" ]]; then
          yb_array+=("${spacer}${key}_ ${value}${outer}")
        else
          yb_array+=("${spacer}${key}_${value}${outer}")
        fi
      else
        yb_array+=("${spacer}${value}${outer}")
      fi
    fi
  else
    # if '-R' is false, use colors
    if [[ "${yb_is_raw}" == false ]] && [[ "${yb_format}" == false ]]; then
      if [[ "${type}" == "comment" ]]; then
          value=$(_to_color "${value}" "${yb_grey}")
      elif [[ "${line_print["type"]}" == *"key"* ]]; then
          key=$(_to_color "${key}" "${yb_blue}")
          prefix=$(_to_color "${prefix}" "${yb_blue}")
      fi
    fi

    if [[ "${yb_is_sequence}" == true && "${yb_one_line}" == true ]]; then
      if [[ "${type}" == *"key:value" ]]; then
        string=$(echo -e "${value}${outer}")
        yb_one_line=false
        yb_is_print=false
        echo "${spacer}"${string}
      fi
    else
      if [[ "${type}" == "comment" ]]; then
        string=$(echo -e "${prefix}${value}${outer}")
        echo "${spacer}"${string}
      else
        string=$(echo -e "${prefix}${key}${suffix}" && echo "${value}${outer}")
        echo "${spacer}"${string}
      fi
    fi
  fi
}

########################################
# Trim leading and trailing spaces
# Attributes:
#   $1 # string
########################################
_trim_space(){
  local string="${@-}"
  string=$(echo "$string" | sed -E 's/^ +//')
  string=$(echo "$string" | sed -E 's/ +$//')
  echo "${string}"
}

########################################
# Trim a leading hyphen and one space
# Attributes:
#   $1 # string
########################################
_trim_hyphen(){
  local string="${@-}"
  string="${string##*- }"
  echo "${string}"
}

########################################
# Add some color tags to a string
# Attributes:
#   $1 # string
#   $2 # an ANSI format color
########################################
_to_color(){
  local text="${1-}"
  local color="${2-}"
  echo "${color}${text}\033[0m"
}

########################################
# Prepare globals for sequence search
########################################
_sequence(){
  # set flags
  yb_is_sequence=true
  yb_retrieve=false
  # get selector key details
  yb_key=($(echo "${yb_key}" | tr -s '.' ' '))
  yb_key_length="${#yb_key[@]}"
}

########################################
# Parse script options
# Attributes:
#   $@ # getopts options
########################################
_parse_options(){
  local file="${yb_file-}"
  local key="${yb_key-}"
  if [[ -f ${file} ]]; then
    if [[ -n "${key}" ]]; then
      _sequence
    fi
  else
    echo "YAML file needs to be provided through the '-f' option."
    exit
  fi
}

########################################
# Initialize the cli
# Attributes:
#   $@ # script user options
########################################
_cli(){
  while getopts "Adf:Fk:lLnRv:s:" arg; do
    case $arg in
      a)
        yb_add=true
        ;;
      A)
        yb_is_array=true
        ;;
      d)
        yb_depth=true
        ;;
      f)
        yb_file="${OPTARG}"
        ;;
      F)
        yb_format=true
        ;;
      k)
        yb_key="${OPTARG}"
        ;;
      l)
        yb_show_line=true
        ;;
      L)
        yb_show_level=true
        ;;
      n)
        yb_show_line_number=true
        ;;
      R)
        yb_is_raw=true
        ;;
      v)
        yb_value="${OPTARG}"
        ;;
      s)
        yb_spacing="${OPTARG}"
        ;;
    esac
  done
  # if no options were provided
  if [[ "${OPTIND}" -eq 1 ]]; then
    # if arguments were provided
    if [[ "${#}" -gt 0 ]]; then
      yb_file="${1-}"
      yb_key="${2-}"
    else
      echo "No parameters provided"
      exit
    fi
  fi
}

########################################
# Main function
# Attributes:
#   $@ # script user options
########################################
main(){
  _globals
  _cli "${@}"
  _parse_options "${@}"
  _parse_yaml "${yb_file}"

  if [[ "${yb_is_array}" == true ]]; then
    echo "${yb_array[@]}"
  fi
}

# Launch main function
main "${@}"
# Unset the eu flag
set +eu