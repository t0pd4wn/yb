#!/bin/bash
#---------------------------------------
# yb | yaml bash parser
#---------------------------------------

# Set the eu flag
set -eu

########################################
# Declare globals
# Attributes:
#   $@ # script user options
########################################
yb::globals(){
  declare -g yb_spacing=2
  declare -g yb_pipe_delimeter="|>"
  declare -g yb_grey="\033[0;30m"
  declare -g yb_blue="\033[1;36m"
  declare -g yb_orange="\033[1;33m"
  declare -g yb_red="\033[31m"
  declare -g yb_italic="\033[3m"
  declare -g yb_add=false
  declare -g yb_remove=false
  declare -g yb_query=false
  declare -g yb_type=false
  declare -g yb_boolean_query=false
  declare -g yb_value_query=false
  declare -g yb_line_number_query=false
  declare -g yb_silent_query=false
  declare -g yb_depth=false
  declare -g yb_format=false
  declare -g yb_is_array=false
  declare -g yb_is_raw=false
  declare -g yb_show_level=false
  declare -g yb_show_line=false
  declare -g yb_show_line_number=false
  declare -g yb_is_sequence=false
  declare -g yb_is_empty=true
  declare -g yb_retrieve=false
  declare -g yb_is_retrieved=false
  declare -g yb_is_print=false
  declare -g yb_one_line=false
  declare -g yb_is_colored=false
  declare -g yb_has_key=false
  declare -g yb_sequence_retrieved=0
  declare -g yb_original_key_length=""
  declare -g yb_key_length=0
  declare -g yb_key_step=0
  declare -g yb_key_base_level=0
  declare -g yb_added_lines=0
  declare -g yb_previous_parent=""
  declare -g yb_parent_type=""
  declare -g yb_parent_level=""
  declare -g yb_set_level=""
  declare -g yb_value=""
  declare -g yb_value_type=""
  declare -g yb_key_option=""
  declare -g yb_value_option=""
  declare -g yb_YAML=""
  declare -g yb_trimmed=""
  declare -g yb_spacer=""
  declare -g yb_anchor=""
  declare -g yb_color_string=""
  declare -g yb_query_search_result=""
  declare -g yb_query_lines_result=""
  declare -g yb_query_search_values_result=""
  declare -g yb_query_pipe_result=""
  declare -g yb_query_pipe_first_line=""
  declare -ga yb_coordinates
  declare -ga yb_query_result
  declare -ga yb_array
  declare -gA yb_keys
}

########################################
# Parse a yaml file
# Globals:
#   yb_YAML
########################################
yb::parse::yaml() {
  local comment
  local yaml
  local separator
  local raw_line
  local line
  local spaces
  local level
  local type
  local key=""
  local value=""
  local parent=""
  local line_number=0
  local prefix
  local suffix

  # associative array that holds the ${line} information
  # it is made available to the yb::parse::* functions
  declare -A line_

  # set whitespace as field separator
  IFS=$' \t\n'

  # loop through each line of the YAML file
  while IFS= read -r raw_line; do
    # keep track of current line number
    line_number=$(( $line_number + 1 ))

    # reset variables values
    key=""
    value=""
    suffix=""
    prefix=""
    yb_trimmed=""

    # copy the raw line to line
    # used to retrieve original spacing for pipe selection
    line="${raw_line}"

    # count the leading spaces to determine the indentation level
    spaces="${line%%[^[:space:]]*}"
    level="${#spaces}"
    level="$(( $level / $yb_spacing ))"

    # remove the leading and trailing spaces
    _trim_space "${line}"
    line="${yb_trimmed}"

    # check the line type
    if [[ -z "${line}" ]]; then 
      type="empty"
    elif [[ "${line}" == "#"* ]]; then
      type="comment"
      value="${line}"
    elif [[ "${line}" == *":" && "${line}" != "-"*":"* ]]; then
      type="key"
      yb_parent_type="key"
      key="${line%%:*}"
      parent="${key}"
      yb_previous_parent="${key}"
      suffix=": "
    elif [[ "${line}" == *": "* && ${line} != "- "* ]]; then
      type="key:value"
      yb_parent_type="key:value"
      key="${line%%:*}"
      value="${line#*:}"
      # trim leading space
      _trim_space "${key}"
      key="${yb_trimmed}"
      _trim_space "${value}"
      value="${yb_trimmed}"
      parent="${key}"
      suffix=": "
      if [[ "${value}" == "|" ]]; then
        type="key:pipe"
        yb_parent_type="key:pipe"
      fi
    elif [[ "${line}" == "- "*": "* && "${line}" != *"::"* ]]; then
      type="list-key:value"
      yb_parent_type="list-key:value"
      # trim leading space and list hyphen
      _trim_space "${line}"
      _trim_hyphen "${yb_trimmed}"
      key="${yb_trimmed}"
      key="${key%%:*}"
      value="${line#*:}"
      _trim_space "${value}"
      value="${yb_trimmed}"
      prefix="- "
      suffix=": "
      if [[ "${value}" == "|" ]]; then
        type="list-key:pipe"
        yb_parent_type="list-key:pipe"
        yb_parent_level="${level}"
      fi
      # in this case, the parent is on the previous line
      parent="${yb_previous_parent}"
    elif [[ "${line}" == "-"*":"  && "${line}" != *"::"* ]]; then
        type="list-key"
        yb_parent_type="list-key"
        # trim leading space and list hyphen
        _trim_space "${line}"
        _trim_hyphen "${yb_trimmed}"
        key="${yb_trimmed}"
        key="${key%%:*}"
        prefix="- "
        parent="${key}"
        yb_previous_parent="${key}"
      elif [[ "${line}" == "-"* ]]; then
        type="list-value"
        # Trim leading space and list hyphen
        _trim_space "${line}"
        _trim_hyphen "${yb_trimmed}"
        value="${yb_trimmed}"
        prefix="- "
    else
      type="other"
      value="${line}"
      if [[ "${yb_parent_type}" == *"key:pipe" ]]; then
        type="pipe-value"
        value="${raw_line}"
        level=$(( $yb_parent_level + 1 ))
      fi
    fi

    # populate the associative array
    line_=(
      [type]="${type}"
      [level]="${level}"
      [line_number]="${line_number}"
      [key]="${key-}"
      [value]="${value-}"
      [parent]="${parent-}"
      [prefix]="${prefix-}"
      [suffix]="${suffix-}"
    )

    # call the filtering function
    yb::parse::filter

  done <<< "${yb_YAML}"

  # reset IFS to default value
  unset IFS
}

########################################
# Manage lines structures depending on action
# Globals:
#   $yb_is_sequence
#   $yb_is_print
# Inherit:
#   ${line_[@]}
########################################
yb::parse::filter(){
  local query_prefix="L${level}_N${line_number}"

  # build $spacer and $outer
  yb::string::build_spacer
  yb::string::build_outer

  # if a sequence, search if the path is correct
  if [[ "${yb_is_sequence}" == true ]]; then
     yb::parse::search "${query_prefix}"
    # if path is correct, print
    if [[ "${yb_is_print}" == true ]]; then
      yb::parse::print
    fi
  # if regular print, print
  elif [[ "${yb_is_sequence}" == false ]]; then
    yb::parse::print
  fi
}

########################################
# Search the correct key path
# Attributes:
#   $1 # prefix for -q option
# Globals:
#   $yb_is_print
#   $yb_key_step
#   $yb_retrieve
#   $yb_keys
#   $yb_original_key_step
# Inherit:
#   ${line_[@]}
########################################
yb::parse::search(){
  local query_prefix="${1-}"
  local key="${line_["key"]}"
  local new_level
  local step_length
  yb_is_print=false

  new_level="${yb_key_step}"

  # if the current level is lower than the expected one, reset
  if [[ "${line_["level"]}" -lt "${new_level}" ]]; then
    yb_key_step=0
    yb_retrieve=false 
    new_level="${yb_key_step}"
  fi

  if [[ "${line_["type"]}" == *"key:pipe" && ${yb_keys[${yb_key_step}]} == *"|" ]]; then
    key="${key}|"
  fi

  if [[ "${yb_retrieve}" == false ]]; then
    # the key and the level are the expected ones, first key is at the root level (0)
    if [[ "${line_["prefix"]}${key}" == "${yb_keys[${yb_key_step}]}" && "${line_["level"]}" -eq "${new_level}" ]]; then
      step_length=$(( $yb_key_step + 1 ))
      if [[ "${line_["type"]}" == *"key:pipe" && ${step_length} -lt ${yb_original_key_length} ]]; then
        echo "yb: pipe type key can not be nested in another pipe type key."
        exit 0
      fi
      # set new index
      yb_key_step=$(( $yb_key_step + 1 ))
      # if enough arguments
      if [[ "${yb_key_step}" -eq "${yb_key_length}" ]]; then
        if [[ "${yb_line_number_query}" == true ]]; then
          # if looking for the key coordinates
          yb_query_lines_result+=("${query_prefix}")
        fi
        if [[ "${yb_boolean_query}" == true ]]; then
          # if looking for the key existence confirm and exit
          yb_query_result=true
          if [[ "${yb_add}" == false ]]; then
            # if not in an addition scenario
            echo ${yb_query_result}
          fi
        fi

        yb_retrieve=true
        yb_key_base_level="${level}"
        # assume the key exist
        yb_has_key=true

        # if searched value is *key:value, retrieve only once
        if [[ "${line_["type"]}" == *"key:value" ]]; then
          # search result is only one line
          yb_one_line=true
          # sequence is over, reset flags
          yb_key_step=0
          yb_retrieve=false
          # send a true signal to print the current line
          yb_is_print=true
          # add one to the number of retrieved sequences
          yb_sequence_retrieved=$(( yb_sequence_retrieved + 1 ))
          # assume the value was filled once
          yb_is_empty=false
          return 0
        fi
      fi
    fi
  elif [[ "${yb_retrieve}" == true && "${line_["level"]}" -gt "${yb_key_base_level}" ]]; then
    # if search parameters match with current line
    # send a true signal to print the current line
    yb_one_line=false
    yb_is_print=true
    # assume the value was filled once
    yb_is_empty=false
  else
    # if not
    yb_one_line=false
    yb_is_print=false
    # if the level is lower or equal the key level
    # sequence is over, reset flags
    yb_key_step=0
    # yb_is_retrieved=false
    yb_retrieve=false
    # add one to the number of retrieved sequences
    yb_sequence_retrieved=$(( yb_sequence_retrieved + 1 ))
  fi
}

########################################
# Print to terminal
# Inherit:
#   ${line_[@]}
########################################
yb::parse::print(){
  local level=${line_["level"]}
  local type="${line_["type"]}"
  local key="${line_["key"]}"
  local value="${line_["value"]}"
  local prefix="${line_["prefix"]}"
  local suffix="${line_["suffix"]}"
  local line_number="${line_["line_number"]}"
  local spacer="${line_["spacer"]}"
  local outer="${line_["outer"]}"
  local string=""
  local has_colors=""
  yb_is_colored=false
  yb_value=""
  yb_value_type=""

  # if a line-number query or a boolean query, exit
  # note: they are dealt with in yb::parse::print
  if [[ "${yb_line_number_query}" == true || "${yb_boolean_query}" == true ]]; then
    return 0
  fi

  # if type option is set to true
  if [[ "${yb_type}" == true ]]; then
    if [[ "${line_["type"]}" == *"value"* ]]; then
        string::value_type "${line_["value"]}" "${line_["type"]}"
    fi
  fi

  # if a value query
  if [[ "${yb_value_query}" == true ]]; then

    # if value is a pipe value block
    if [[  "${yb_parent_type}" == *"key:pipe" ]]; then
      yb_query_pipe_result+="${value}"
      # if current value is exactly the beginning of search value
      if [[ "${yb_value_option}" =~ "${yb_query_pipe_result}"* ]]; then
        # capture first line number of the pipe block
        if [[ -z "${yb_query_pipe_first_line}" ]]; then
          yb_query_pipe_first_line=${line_number}
        fi
        # when value is found completely
        if [[ "${yb_query_pipe_result}" == "${yb_value_option}" ]]; then
          if [[ "${yb_show_line}" == true ]]; then
            yb_query_result+="true{{T_${type}}}{{N_${yb_query_pipe_first_line}_${line_number}}}"
          else
            yb_query_result=true
          fi
          if [[ "${yb_silent_query}" == false ]]; then

            echo ${yb_query_result}
          fi
        fi
      else
        # reset temp values
        yb_query_pipe_result=""
        yb_query_pipe_first_line=""
      fi

    fi

    # if value is the same as the searched option (inline or list values)
    if [[ "${yb_value_option}" == "${value}" || "${yb_value_option}" == "- ${value}" ]]; then
      if [[ "${yb_show_line}" == true ]]; then
        yb_query_result+="true{{T_${type}}}{{N_${line_number}}} "
      else
        yb_query_result=true
      fi
      if [[ "${yb_silent_query}" == false ]]; then
        echo ${yb_query_result}
      fi
    fi
    return 0
  fi

  # if an array
  if [[ "${yb_is_array}" == true ]]; then
    if [[ "${type}" != "comment" && "${type}" != "empty" ]]; then
      if [[ "${type}" == *"key"* ]]; then
        if [[ "${type}" == "list-key:value" ]]; then
          if [[ "${yb_one_line}" == false ]]; then
            yb_array+=("${spacer}${key}_ ${yb_value_type}${value}${outer}")
          else
            yb_array+=("${spacer}${yb_value_type}${value}${outer}")
          fi
        else
          if [[ "${yb_one_line}" == false ]]; then
            yb_array+=("${spacer}${key}_${yb_value_type}${value}${outer}")
          else
            yb_array+=("${spacer}${yb_value_type}${value}${outer}")
          fi
        fi
      else
        yb_array+=("${spacer}${yb_value_type}${value}${outer}")
      fi
    fi
  else
    # if '-R' is false, use colors
    if [[ "${yb_is_raw}" == false ]] && [[ "${yb_format}" == false ]]; then
      if [[ "${type}" == "comment" ]]; then
        _set_color "${value}" "${yb_grey}"
        value="${yb_color_string}"
      elif [[ "${line_["type"]}" == *"key"* ]]; then
        _set_color "${key}" "${yb_blue}"
        key="${yb_color_string}"
        _set_color "${prefix}" "${yb_blue}"
        prefix="${yb_color_string}"
      fi
      if [[ "${line_["type"]}" == *"value"* ]]; then
        string::color_type "${value}"
        if [[ -n "${yb_value}" ]]; then
          value="${yb_value}"
        fi
      fi
    fi

    # if a *key:value sequence
    if [[ "${yb_is_sequence}" == true && "${yb_one_line}" == true ]]; then
      if [[ "${type}" == *"key:value" ]]; then
        if [[ "${yb_is_colored}" == true ]]; then
          echo -e "${value}${outer}"
        else
          echo "${value}${outer}"
        fi
        yb_one_line=false
        yb_is_print=false
      fi
    else
      if [[ "${type}" == "comment" ]]; then
        string=$(echo -e "${prefix}${yb_value_type}${value}${outer}")
        echo "${spacer}"${string}
      else
        if [[ ${yb_is_colored} == true ]]; then
         string=$(echo -e "${prefix}${key}${suffix}${yb_value_type}${value}${outer}")
        else
         string=$(echo -e "${prefix}${key}${suffix}" && echo "${yb_value_type}${value}${outer}")
        fi

      if [[ "${type}" == *"key:pipe" ]]; then
         echo "${spacer}"${string}
        # if a pipe value no color support
       elif [[ "${yb_parent_type}" == *"key:pipe" ]]; then
          string="${prefix}${key}${suffix}${yb_value_type}${value}${outer}"
          echo "${spacer}""${string}"
        else
          echo "${spacer}"${string}
        fi

      fi
    fi
  fi
}

########################################
# Query file for an existing key
# Attributes:
#   $1 # mode (boolean verbose)
#   $2 # a key
# Globals:
#   yb_boolean_query
#   yb_line_number_query
#   yb_file
#   yb_is_empty
#   yb_query
#   yb_query_result
########################################
_query_search(){
  
  declare -a key=("${1-}")
  local result
  yb_key_step=0
  yb_query_search_result=""
  yb_query_result=""

  # set the query mode
  yb_boolean_query=true

  # prepare the search sequence and parse file
  yb::sequence "${key[@]}"
  yb::parse::yaml "${yb_file}"

  # if result contains true and not an addition scenario
  if [[  "${yb_query_result}" == *"true"* && "${yb_add}" == "false" ]]; then
    # output has been returned, exit
    exit 0
  fi

  # get the result
  result="${yb_query_search_result}"

  if [[ -n "${result}" ]]; then
    # has result
    yb_query_result=true
  elif [[ "${yb_is_empty}" == false ]]; then
    # has result but empty one
    if [[ -n "${yb_value_option}" ]]; then
      yb_query_result=false
    else
      yb_query_result=true
    fi
  elif [[ "${result}" == "" ]]; then
    yb_query_result=false
  else
    # no result
    yb_query_result=false
  fi

  # reset flag
  yb_boolean_query=false
}

yb::file::delete_line(){
  local line_to_delete="${1-}"
  local temp_file="${yb_file}.temp"
  local line_count=0

  # _debug "${line_to_delete}"

    # read the file content into an array
    # IFS=$'\n' read -d '' -r -a linest < "${yb_file}"

  IFS=$'\n'


  # loop through each line of the YAML file
  while IFS= read -r line; do

    line_count=$(( $line_count + 1 ))
    if [[ "${line_count}" == "${line_to_delete}" ]]; then
      continue
    else
      echo "${line}" >> "${temp_file}"
    fi

  done <<< "${yb_YAML}"

    mv "${temp_file}" "${yb_file}"
}

########################################
# Query file for an existing value
# Attributes:
#   $1 # a key
# Globals:
#   yb_key_step
#   yb_query_search_result
#   yb_query_result
#   yb_value_query
#   yb_file
########################################
_query_search_values(){
  declare -a key=(${@-})
  local result
  yb_key_step=0
  yb_query_result=""
  yb_query_pipe_result=""

  # set the query mode
  yb_value_query=true

  # prepare the search sequence and parse file
  yb::sequence "${key[@]}"
  yb::parse::yaml "${yb_file}"

  # if a pipe result is retrieved
  if [[ -z "${yb_query_pipe_result}" ]]; then
    if [[ "${yb_query_pipe_result}" == "${yb_value_option}" ]]; then
      yb_query_result=true
    fi
  fi

  # if no results are found
  if [[ -z "${yb_query_result}" ]]; then
    yb_query_result=false
  fi

  # reset the query mode
  yb_value_query=false
}

########################################
# Query file for an existing key
# Attributes:
#   $1 # mode (boolean verbose)
#   $2 # a key
# Globals:
#   yb_boolean_query
#   yb_line_number_query
#   yb_file
#   yb_is_empty
#   yb_query
#   yb_query_result
########################################
_query_keys_lines(){
  # local mode="${1-}"
  declare -a key=("${1-}")
  local result
  # empty global array before retrieving results
  yb_query_lines_result=()
  yb_query_result=()
  yb_key_step=0

  # set mode flag
  yb_line_number_query=true

  # prepare the search sequence
  yb::sequence "${key[@]}"
  yb::parse::yaml "${yb_file}"

  # get the result
  result="${yb_query_lines_result[@]}"
  yb_query_result="${result[@]}"

  # reset flag
  yb_line_number_query=false
}

########################################
# Query file for values coordinates
# Attributes:
#   $1 # a key
# Globals:
#   yb_boolean_query
#   yb_line_number_query
#   yb_file
#   yb_is_empty
#   yb_query
#   yb_query_result
########################################
_query_values_lines(){
  # local mode="${1-}"
  declare -a key=("${1-}")
  local result
  # empty global array before retrieving results
  yb_query_search_values_result=()
  yb_query_result=()
  yb_key_step=0

  # set mode flag
  yb_is_array=true
  yb_show_line_number=true
  yb_search_values_query=true

  # prepare the search sequence
  yb::sequence "${key[@]}"
  yb::parse::yaml "${yb_file}"

  # get the result
  result="${yb_array[@]}"
  yb_query_result="${result[@]}"

  # reset flag
  yb_is_array=false
}

#########################################
# # Add path child keys
# # Attributes:
# #   $@ # an array of key coordinates (level, line number)
# ########################################
_add_child_keys(){
    declare -a keys_anchors=(${@})
    local parent_level
    local parent_line

    for anchor in "${keys_anchors[@]}"; do
      parent_level="${anchor%%_N*}"
      parent_level="${parent_level#*L}"
      parent_line="${anchor#*N}"

      _add_keys_in_file "${parent_line}" "${parent_level}"
    done
}

########################################
# Add key(s) in a file
# Attributes:
#   $1 # line number
#   $2 # level
#   $3 # index
# Globals:
#   yb_key
#   yb_key_length
########################################
_add_keys_in_file(){
  local parent_line_number="${1-}"
  local parent_level="${2-}"
  local spacing="\ \ "
  local spacer
  local target_line_number
  local counter=0

  # find the correct line depending on previous additions
  target_line_number=$(( $parent_line_number + $yb_added_lines ))

  # referesh keys referential
  _key_to_array "${yb_key_option}"

  for (( aif = $parent_level + 1; aif < $yb_key_length; aif++ )); do 
    spacer=""
    for (( sp = 0; sp < $parent_level + 1; sp++ )); do
      spacer+="${spacing}"
    done

    # if a pipe key
    if [[ "${yb_keys[${aif}]}" == *"|" ]]; then
      child_key="${spacer}${yb_keys[${aif}]%?}:"
      if [[ "${aif}" -eq $(( $yb_key_length - 1 )) ]]; then
       child_key="${spacer}${yb_keys[${aif}]%?}: |"
      fi
    else 
      child_key="${spacer}${yb_keys[${aif}]}:"
    fi

    # write in file
    sed -i "${target_line_number} a ${child_key}" "${yb_file}"
    # increment levels and line numbers for next iteration
    parent_level=$(( $parent_level + 1 ))
    target_line_number=$(( $target_line_number + 1 ))
    # increment the global added lines
    counter=$(( $counter + 1 ))
  done
  yb_added_lines=$(( $yb_added_lines + $counter ))
}

########################################
# Add new key(s) in a file
# Globals:
#   yb_key
#   yb_key_length
########################################
_add_new_keys_in_file(){
  local level=0
  local spacing="  "
  local spacer
  # local target_line_number
  local counter=0

  # referesh keys referential
  _key_to_array "${yb_key_option}"

  for (( aif = 0 ; aif < $yb_key_length; aif++ )); do 
    spacer=""
    for (( sp = 0; sp < level; sp++ )); do
      spacer+="${spacing}"
    done

    # if a pipe key
    if [[ "${yb_keys[${aif}]}" == *"|" ]]; then
      child_key="${spacer}${yb_keys[${aif}]%?}:"
      if [[ "${aif}" -eq $(( $yb_key_length - 1 )) ]]; then
       child_key="${spacer}${yb_keys[${aif}]%?}: |"
      fi
    else 
      child_key="${spacer}${yb_keys[${aif}]}:"
    fi

    # write in file on the last line
    sed -i "\$s/\$/ \n$child_key/" "${yb_file}"
    # increment levels and line numbers for next iteration
    level=$(( $level + 1 ))
  done
}

########################################
# Build the key coordinates
# Globals:
#   yb_key
#   yb_key_length
#   yb_coordinates
########################################
_manage_keys_addition(){
  local has_key
  declare -a coordinates
  declare -a keys=("${yb_keys[@]}")
  local sequence_length="${yb_key_length}"
  local search_key=""

  local counter=$sequence_length  

  reverse_array=()
  for (( r = ${#keys[@]} - 1; r >= 0; r-- )); do
      reverse_array+=("${keys[r]}")
  done  

  for (( s = 0; s < $sequence_length; s++ )); do
    search_key="" 

    for (( rs = 0; rs < $counter; rs++ )); do
      search_key+=".${reverse_array[$rs]}"
    done  

    # strip first character (a ".")
    search_key="${search_key:1}"

    _query_keys_lines "${search_key}"
    # get result
    has_key=("${yb_query_result}")

    # this gives a behavior where only 
    # the first level of parents are targeted
    if [[ -n "${has_key}" ]]; then
      break;
    fi

    counter=$(( $counter - 1 ))
  done

  if [[ -z "${has_key}" ]]; then
    _add_new_keys_in_file


  else
    _add_child_keys "${has_key}"
  fi
}

########################################
# Add key(s) in a file
# Attributes:
#   $1 # line number
#   $2 # level
#   $3 # index
# Globals:
#   yb_key
#   yb_key_length
########################################
_add_value_in_file(){
  declare -a parents=(${1-})
  local spacing="\ \ "
  local spacer
  local target_line_number
  local counter=0
  local existing_line
  local value_type
  local key_line
  local key_level
  local parent_key_value
  local inline_value
  declare -a value_array
  declare -a clean_value_array

  # set mode
  if [[ "${yb_value_option}" == "- "* ]]; then
    value_type="list"
  elif [[ "${yb_value_option}" == "|"* ]]; then
    value_type="pipe"
  else 
    value_type="inline"
  fi

  if [[ "${value_type}" == "inline" ]]; then
    # iterate over parent keys
    for key in "${parents[@]}"; do
      key_line="${key##*_N}"
      # get the existing content from the line
      parent_key_value=$(sed -n "${key_line}p" "$yb_file")
      # prepare line value
      # todo : explore use of echo here
      inline_value=$(echo "${parent_key_value} ${yb_value_option}")
      # write key:value on the same line
      sed -i "${key_line}c\\$inline_value" "$yb_file"
    done

  elif [[ "${value_type}" == "list" ]]; then

    # add a space before the string to cope with delimeter
    yb_value_option=" ${yb_value_option}"

    # declare parsing values
    string="${yb_value_option}"
    delimiter=' - '
    condition=$string$delimiter

    # check for delimeter in string
    while [[ $condition ]]; do
        value_array+=( "${condition%%"$delimiter"*}" );
        condition=${condition#*"$delimiter"};
    done;

    # iterate over values to clean them
    for raw_value in "${value_array[@]}"; do
      if [[ -n "${raw_value}" ]]; then
        _trim_space ${raw_value}
        raw_value="${yb_trimmed//\\/\\\\}"
        clean_value_array+=("${raw_value}")
      fi
    done

    # iterate over parent keys
    for key in "${parents[@]}"; do
      key_line="${key##*_N}"
      key_level="${key%%_N*}"
      key_level="${key_level##L}"

      # build spacer
      spacer=""
      for (( sp = 0; sp < $key_level + 1; sp++ )); do
        spacer+="${spacing}"
      done

      local clean_array_length=${#clean_value_array[@]}

      for (( cv = clean_array_length - 1; cv >= 0 ; cv-- )); do
        key_line=$(( $key_line + $counter ))
        clean_value="${spacer}- ${clean_value_array[$cv]}"
        sed -i "${key_line} a ${clean_value}" "${yb_file}"
      done
      counter=$(( $counter + 1 ))
    done

  elif [[ "${value_type}" == "pipe" ]]; then
    # add a space before the string to cope with delimeter
    yb_value_option=" ${yb_value_option}"

    # declare parsing values
    string="${yb_value_option}"
    delimiter=" ${yb_pipe_delimeter} "
    condition=$string$delimiter

    # check for delimeter in string
    while [[ $condition ]]; do
        value_array+=( "${condition%%"$delimiter"*}" );
        condition=${condition#*"$delimiter"};
    done;

    # iterate over values to clean them
    for raw_value in "${value_array[@]}"; do
      if [[ -n "${raw_value}" ]]; then
        # _trim_space ${raw_value}
        raw_value="${raw_value//\\/\\\\}"
        clean_value_array+=("${raw_value}")
      fi
    done

    # iterate over parent keys
    for key in "${parents[@]}"; do
      key_line="${key##*_N}"
      key_level="${key%%_N*}"
      key_level="${key_level##L}"

      # build spacer
      spacer=""
      for (( sp = 0; sp < $key_level + 1; sp++ )); do
        spacer+="${spacing}"
      done

      local clean_array_length=${#clean_value_array[@]}

      for (( cv = clean_array_length - 1; cv >= 0 ; cv-- )); do
        clean_value="${spacer}${clean_value_array[$cv]}"
        sed -i "${key_line} a ${clean_value}" "${yb_file}"
      done
    done
  fi
}

########################################
# Manage value addition
# Globals:
#   yb_key
#   yb_key_length
#   yb_coordinates
########################################
_manage_value_addition(){
  local has_key
  declare -a keys=("${yb_keys[@]}")
  local sequence_length="${yb_key_length}"
  local search_key=""

  local counter=$sequence_length  

  # query for lines coordinates
  _query_keys_lines "${search_key}"
  # get result
  has_key=("${yb_query_result}")

  _add_value_in_file "${has_key}"
}

########################################
# Add key(s) and/or value(s)
# Globals:
#   yb_key
#   yb_query
########################################
_add(){
  _query_search "${yb_key_option}"

  if [[ "${yb_query}" == false ]]; then
    _manage_keys_addition "${yb_key_option}"
    _cache_yaml
  fi

  if [[ -n "${yb_value_option-}" ]]; then
    _manage_value_addition "${yb_value_option}"
  fi

  # as sed tends to add trailing whitespaces remove them
  sed -i 's/[[:space:]]*$//'  "${yb_file}"
}

########################################
# Remove key(s) and/or value(s)
# Globals:
#   yb_key_option
#   yb_query_result
#   yb_file
########################################
_remove(){
  declare -a parent_lines=()
  declare -a child_lines=()

  yb_query_result=()
  declare -a child_array
  declare -a remove_lines
  local next_line
  local remove_line
  local line_counter=0

  # get lines for parents and children
  _query_keys_lines "${yb_key_option}"
  parent_lines=(${yb_query_result})
  _query_values_lines "${yb_key_option}"
  child_lines=(${yb_query_result})

  if [[ -z "${parent_lines[@]}" && -z "${child_lines[@]}" ]]; then
    # nothing to remove
    return 0
  fi

  # prepare child lines numbers
  if [[ -n "${child_lines[@]}" ]]; then
    for child in "${child_lines[@]}"; do
      child="${child##*'{{'}"
      child="${child%%'}}'}"
      child_array+=("${child}")
    done
  fi

  # prepare overall line numbers
  for parent in "${parent_lines[@]}"; do
    parent="${parent##*_N}"
    next_line=$(( $parent + 1 ))
    remove_lines+=("${parent}")
    if [[ -n "${child_array[@]}" ]]; then
      for (( ch = 0; ch < "${#child_array[@]}"; ch++ )); do
        # note: this may not work for files with 99+ lines
        if [[ "${child_array[*]}" =~ "${next_line}" ]]; then
          remove_lines+=("${next_line}")
          next_line=$(( $next_line + 1 ))
        else
          # if lines are not consecutive, break
          break;
        fi
      done
    fi
  done

  # iteratevely delete line numbers and adjust line number accordingly
  for (( li = 0; li < "${#remove_lines[@]}"; li++ )); do
    remove_line="${remove_lines[${li}]}"
    remove_line=$(( $remove_line - $line_counter ))
    # yb::file::delete_line "${remove_line}"
    sed -i "${remove_line}d" "${yb_file}"
    line_counter=$(( $line_counter + 1 ))
  done
}

########################################
# Remove a value
# Globals:
#   yb_key_option
#   yb_query_result
#   yb_file
########################################
_remove_value(){
  declare -a parent_lines
  declare -a child_lines
  declare -a child_array
  declare -a remove_lines
  local next_line
  local remove_line
  local line_counter=0
  local first_line_number
  local line_number
  local lines_to_delete
  local line_type
  local result
  local spacing="\ \ "
  local spacer=""
  local last_key_index
  local last_key

  yb_show_line=true
  yb_silent_query=true
  local pipe_query=""

  # check if a pipe value
  if [[ "${yb_key_option: -1}" == "|" ]]; then
    pipe_query=true
  fi

  _query_search_values "${yb_key_option}"
  result=(${yb_query_result})

  if [[ "${result}" == false ]]; then
    return 0
  fi

  for (( rs = 0; rs < "${#result[@]}" ; rs++ )); do
    if [[ "${pipe_query}" == true ]]; then

      line_type="${result[$rs]##*'{{T_'}"
      line_type="${line_type%%'}}{{N_'*}"
      line_number="${result[$rs]##*'{{N_'}"
      line_number="${line_number%%'}}'}"
      first_line_number="${line_number%%'_'*}"
      line_number="${line_number##*'_'}"

      # adjust the line numbers in regards to previous modifications
      first_line_number=$(( $first_line_number - $line_counter ))
      line_number=$(( $line_number - $line_counter ))

    else

      line_type="${result[$rs]##*'{{T_'}"
      line_type="${line_type%%'}}{{N_'*}"
      line_number="${result[$rs]##*'{{N_'}"
      line_number="${line_number%%'}}'}"

      # adjust the line number in regards to previous modifications
      line_number=$(( $line_number - $line_counter ))
    fi

    if [[  "${pipe_query}" == true ]]; then
      lines_to_delete="${line_number}"
      for (( ld = $first_line_number; ld <= $lines_to_delete; ld++ )); do
        sed -i "${line_number}d" "${yb_file}"
        line_number=$(( $line_number - 1 ))
        line_counter=$(( $line_counter + 1 ))
      done

    elif [[ "${line_type}" == *"key:value" ]]; then
      sed -i "${line_number}d" "${yb_file}"
      line_number=$(( $line_number - 1 ))

      # create spacer
      for (( sp = 0; sp < $yb_key_length - 1; sp++ )); do
        spacer+="${spacing}"
      done

      # find key
      last_key_index=$(( $yb_key_length - 1 ))
      last_key="${yb_keys[$last_key_index]}"
      if [[ "${line_type}" == "key:value" ]]; then
        last_key="${spacer}${last_key}:"
      elif [[  "${line_type}" == "list-key:value" ]]; then
        last_key="${spacer}${last_key}:"
      fi
      # re-add the key
      sed -i "${line_number} a ${last_key}" "${yb_file}"

      # clean spacer
      spacer=""
    else
      sed -i "${line_number}d" "${yb_file}"
      # increment line count
      line_counter=$(( $line_counter + 1 ))
    fi
  done

  # reset flag
  yb_show_line=false
  yb_silent_query=false
}

########################################
# Build the spacer that comes before a key or value
# Globals:
#   $yb_format
#   $yb_spacing
#   $yb_set_level
#   $yb_spacer
# Inherit:
#   ${line_[@]}
########################################
yb::string::build_spacer(){
  local level="${line_["level"]}"
  local style=""
  local separator=""
  local spacer=""

  # set the correct starting level
  if [[ ${yb_is_sequence} == true ]]; then
    level=$(( $level - 1 ))
  else 
    level=$(( $level + 1 ))
  fi

  # switch the separator type
  if [[  "${yb_format}" == true ]]; then
    style="."
    separator="${style}"
    level=$(( $level + 1 ))
  else
    style=" "
    # set the separator length based one
    for (( i = 0; i < $yb_spacing; i++ )); do
      separator+="${style}"
    done
  fi

  yb::string::set_level "${level}"

  level="${yb_set_level}"

  for (( i = 0; i < $level; i++ )); do
    spacer+="${separator}"
  done
  
  if [[ "${line_["type"]}" == *"value"* && "${yb_format}" == true ]]; then
      spacer+="${line_["parent"]}_"
  fi

  line_["spacer"]="${spacer}"
}

########################################
# Set the correct level depending on -options
# Globals:
#   yb_is_sequence
#   yb_depth
#   yb_is_array
#   yb_format
#   yb_key_base_level
# Attributes:
#   $1 # current $level
########################################
yb::string::set_level(){
  local level="${1-}"

  # set the correct level number
  if [[ ${yb_is_sequence} == false ]]; then
    level=$(( $level - 1 ))
  elif [[ ${yb_depth} == true ]]; then
    level=$(( $level + 1 ))
  elif [[ "${yb_is_array}" == true && "${yb_format}" == false ]]; then
    level=0
  elif [[ "${yb_is_sequence}" == true ]]; then
    local base_level="${yb_key_base_level}"
    level=$(( $level - $base_level ))
  fi

  # assign the resulting value to the global
  yb_set_level="${level}"
}

########################################
# Build the outer that comes after a key or value
# Globals:
#   $yb_show_line
#   $yb_show_level
#   $yb_show_line_number
#   $yb_outer
# Inherit:
#   ${line_[@]}
########################################
yb::string::build_outer(){
  local outer=""
  local line_spacer="{{line}}"
  local line_level_spacer="{{${line_["level"]}}}"
  local line_number_spacer="{{${line_["line_number"]}}}"

  # add an outer {{line}} for each line
  if [[ "${yb_show_line}" == true ]]; then
    outer+="${line_spacer}"
  fi
  # add an outer {{$level}} for each line
  if [[ "${yb_show_level}" == true ]]; then
    outer+="${line_level_spacer}"
  fi
  # add an outer {{$line_number}} for each line
  if [[ "${yb_show_line_number}" == true ]]; then
    outer+="${line_number_spacer}"
  fi
  line_["outer"]="${outer}"
  # yb_outer="${outer}"
}

########################################
# Check for a value type
# Attributes:
#   $1 # a value
#   $2 # a value type
# Globals:
#   $yb_value_type
########################################
string::value_type(){
  local value="${1-}"
  local type="${1-}"
  local boolean_regex='^(?i)true$'
  local float_regex='^[0-9.]+$'
  yb_value_type=""

  # see https://yaml.org/spec/1.2.2/#1011-tags
  # partial support, missing keys types
  if [[ "${type}" == "comment" ]]; then
    continue
  elif [[ "${value}" =~ ^(true|TRUE|false|FALSE)$ ]]; then
    yb_value_type="!! bool "
  elif [[ "${value}" =~ ^[0-9]+$ ]]; then
    yb_value_type="!! int "
  elif [[ "${value}" =~ ^(null|NULL)$ ]]; then
    yb_value_type="!! null "
  # regex variable need to be unquoted
  elif [[ "${value}" =~ ${float_regex} ]]; then
    yb_value_type="!! float "
  elif [[ -n "${value}" ]]; then
    yb_value_type="!! str "
  fi
}

########################################
# Check for a value type
# Attributes:
#   $1 # a value
########################################
string::color_type(){
  local value="${1-}"

  if [[ "${yb_value_type}" == "!! bool " ]]; then
    _set_color "${value}" "${yb_red}"
    yb_value="${yb_color_string}"
    yb_is_colored=true
  elif [[ "${yb_value_type}" == "!! int " || "${yb_value_type}" == "!! float " ]]; then
    _set_color "${value}" "${yb_orange}"
    yb_value="${yb_color_string}"
    yb_is_colored=true

  elif [[ "${yb_value_type}" == "!! null " ]]; then
    _set_color "${value}" "${yb_italic}"
    yb_value="${yb_color_string}"
    yb_is_colored=true
  fi
}

########################################
# Trim leading and trailing spaces
# Attributes:
#   $1 # string
########################################
_trim_space(){
  local string="${@-}"

  string="${string#"${string%%[![:space:]]*}"}"
  string="${string%"${string##*[![:space:]]}"}"

  yb_trimmed="${string}"
}

########################################
# Trim a leading hyphen and one space
# Attributes:
#   $1 # string
########################################
_trim_hyphen(){
  local string="${@-}"

  # string="${string##*- }"
  string="${string#- }"

  yb_trimmed="${string}"
}

########################################
# Add some color tags to a string
# Attributes:
#   $1 # string
#   $2 # an ANSI format color
########################################
_set_color(){
  local text="${1-}"
  local color="${2-}"
  yb_color_string="${color}${text}\033[0m"
}


########################################
# Print a debug message
# Attributes:
#   $@ # some message
########################################
_debug(){
  local message="${@}"
  echo "${BASH_LINENO} : ${message}"
}

########################################
# Transform original key option into an array
# Attributes:
#   $1 # a yaml key
# Globals:
#   yb_key_option
#   yb_key_length
# Output:
#   yb_keys[@]
########################################
_key_to_array(){
  local keys="${1:-"${yb_key_option}"}"
  local local_index
  declare -a local_array
  yb_keys=()

  # replace space with anti-backslash
  keys="${keys// /\\}"
  # replace points with spaces
  keys="${keys//./ }"
  # transform the string in an array
  keys=(${keys})

  yb_key_length="${#keys[@]}"

  for (( yk = 0; yk < $yb_key_length; yk++ )); do
    key="${keys[$yk]}"
      if [[ "${key}" == *\\* ]]; then
        # replace anti-backslash with space
        key="${key//\\/ }"
      fi
      yb_keys[$yk]="${key}"
  done

  if [[ -z "${yb_original_key_length}" ]]; then
    yb_original_key_length="${yb_key_length}"
  fi
}

########################################
# Prepare globals for sequence search
# Attributes:
#   $1 # a yaml key
########################################
yb::sequence(){
  local key=${@:-"${yb_key_option}"}

  # set flags
  yb_is_sequence=true
  yb_retrieve=false

  _key_to_array "${key}"
}

########################################
# Lock YAML file
# Attributes:
#   $1 # a yaml file
########################################
yb::file::lock(){
  local file="${1}"
  local path="${file%/*}"
  local filename="${file##*/}"

  if [[ "${file}" == */* ]]; then
    path="${path}/.${filename}.yb.lock"
  else
    path=".${file}.yb.lock"
  fi

  if [[ -f "${path}" ]]; then
    echo "File is currently being processed with yb."
    exit 1
  else
    touch "${path}"
  fi
}

########################################
# Unlock YAML file
# Attributes:
#   $1 # a yaml file
########################################
yb::file::unlock(){
  local file="${1}"
  local path="${file%/*}"
  local filename="${file##*/}"

  if [[ "${file}" == */* ]]; then
    path="${path}/.${filename}.yb.lock"
  else
    path=".${file}.yb.lock"
  fi

  rm "${path}"
}

########################################
# Parse script options
# Attributes:
#   $@ # getopts options
# Globals:
#   yb_line_number_query
########################################
yb::start(){
  local file="${yb_file-}"
  local key="${yb_key_option-}"

  _cache_yaml "${file}"

  if [[ "${yb_query}" == true ]]; then
    # if looking for a value
    if [[ -n "${yb_value_option}" ]]; then
      _query_search_values "${key}"
      if [[ "${yb_query_result}" == false ]]; then
        echo "${yb_query_result}"
      fi
    else
      _query_search "${key}"
      echo "${yb_query_result}"
    fi
  elif [[ "${yb_add}" == true ]]; then
    _add
  elif [[ "${yb_remove}" == true ]]; then
    if [[ -n "${yb_value_option}" ]]; then
      _remove_value
    else
      _remove
    fi
  elif [[ -n "${key}" ]]; then
    yb::sequence
    yb::parse::yaml "${yb_file}"
  elif [[ -z "${key}" ]]; then
    yb::parse::yaml "${yb_file}"
  fi

  if [[ "${yb_is_array}" == true ]]; then
    echo "${yb_array[@]}"
  fi
}

########################################
# Cache yaml file into a global variable
# Attributes:
#   $1 # a yaml file path
########################################
_cache_yaml(){
  local file="${1:-${yb_file}}"
  yb_YAML=$(<"${file}")
}

########################################
# Dump array, print an error and exit
########################################
_exit_dump() {
  echo "${yb_array[@]}"
  _error "${@-}"
  _exit
}

########################################
# Print an error and exit
########################################
_exit() {
  # unlock YAML file
  yb::file::unlock "${yb_file}"
  # exit
  exit 0
}

########################################
# Print an error message in STDERR
########################################
_error() {
  echo "${FUNCNAME[1]} : [$(date +'%Y-%m-%dT%H:%M:%S%z')]:: ${@-}" 2>&1
}

########################################
# Initialize the cli
# Attributes:
#   $@ # script user options
########################################
yb::cli(){
  while getopts "aAdf:Fk:lLnqrRTv:" arg; do
    case $arg in
      a)
        yb_add=true
        ;;
      A)
        yb_is_array=true
        ;;
      d)
        yb_depth=true
        ;;
      f)
        yb_file="${OPTARG}"
        ;;
      F)
        yb_format=true
        ;;
      k)
        yb_key_option="${OPTARG}"
        ;;
      l)
        yb_show_line=true
        ;;
      L)
        yb_show_level=true
        ;;
      q)
        yb_query=true
        ;;
      n)
        yb_show_line_number=true
        ;;
      r)
        yb_remove=true
        ;;
      R)
        yb_is_raw=true
        ;;
      T)
        yb_type=true
        ;;
      v)
        yb_value_option="${OPTARG}"
        ;;
    esac
  done
  # if no options were provided
  if [[ "${OPTIND}" -eq 1 ]]; then
    # if arguments were provided
    if [[ "${#}" -gt 0 ]]; then
      yb_file="${1-}"
      yb_key_option="${2-}"
    else
      echo "No parameters provided"
      exit
    fi
  fi
}

########################################
# Main function
# Attributes:
#   $@ # script user options
########################################
yb::main(){
  yb::globals
  yb::cli "${@}"

  # check for the existence of the parameter file
  if ! [[ -f "${yb_file}" ]]; then
    echo "A YAML file needs to be provided through the '-f' option."
    exit
  fi

  # trap the exit function
  trap _exit_dump SIGINT
  trap _exit EXIT

  # lock YAML file
  yb::file::lock "${yb_file}"

  # parse cli options and launch methods
  yb::start "${yb_file}"
}

# Launch main function
yb::main "${@}"
# Unset the eu flag
set +eu