#!/bin/bash
#---------------------------------------
# yb | yaml bash parser
#---------------------------------------

# Setting the eu flag
set -eu

########################################
# Declare globals
# Attributes:
#   $@ # script user options
########################################
_globals(){
  declare -g yb_spacing=2
  declare -g yb_grey="\033[0;30m"
  declare -g yb_blue="\033[1;36m"
  declare -g yb_orange="\033[1;33m"
  declare -g yb_format=false
  declare -g yb_is_array=false
  declare -g yb_is_raw=false
  declare -g yb_show_line=false
  declare -g yb_show_line_number=false
  declare -ga yb_array
  # declare -A yb_line
  declare -g yb_file_line_number
  declare -g yb_is_sequence=false
  declare -g yb_key_length=0
  declare -g yb_key_step=0
  declare -g yb_key_base_level
  declare -g yb_retrieve
  declare -g yb_is_retrieved=false
}

########################################
# Parse a yaml file
# Attributes:
#   $1 # /path/to/a/yaml/file 
########################################
_parse_yaml() {
  local file="${1-}"
  local bold_colon="$(_to_color ":" "\033[1m")"
  local hyphen="$(_to_color "-" "\033[1m")"
  local comment
  local yaml
  local separator
  local line
  local spaces
  local level
  local type
  local key=""
  local value=""
  local option_color=true
  local line_number=0
  local prefix
  local suffix

  # global associative array
  declare -A line_struct

  # Read the YAML file
  yaml=$(<"${file}")

  # Set whitespace as field separator
  IFS=$' \t\n'

  # Loop through each line of the YAML file
  while IFS= read -r line; do
    # keep track of current line number
    ((line_number += 1))

    # reset variables values
    key=""
    value=""
    suffix=""
    prefix=""

    # Count the leading spaces to determine the indentation level
    spaces="${line%%[^[:space:]]*}"
    level="${#spaces}"
    level="$(( level / yb_spacing ))"

    # Remove the leading and trailing spaces
    line=$(_trim_space "${line}")

    # Check the line type
    if [[ -z "${line}" ]]; then 
      type="empty"
    elif [[ "${line}" == "#"* ]]; then
      type="comment"
      value="${line}"
    elif [[ "${line}" == *":" && $line != *:*:* ]]; then
      type="key"
      key="${line%%:*}"
    elif [[ "${line}" == *": "* && ${line} != "- "* ]]; then
      type="key:value"
      # echo "key-value"
      key="${line%%:*}"
      value="${line#*:}"
      key=$(_trim_space $key)
      value=$(_trim_space $value)
      suffix=": "
    elif [[ "${line}" == "- "*": "* ]]; then
        type="list-key:value"
        key=$(_trim_space "${line}")
        key=$(_trim_hyphen "${key}")
        key="${key%%:*}"
        value="${line#*:}"
        value=$(_trim_space "${value}")
        prefix="- "
        suffix=": "
    elif [[ "${line}" == "- "* ]]; then
      if [[ ${level} -eq 0 ]]; then
        type="list-key"
        # Trim leading space and list hyphen
        key=$(_trim_space "${line}")
        key=$(_trim_hyphen "${line}")
        prefix="- "
      else
        type="list-value"
        # Trim leading space and list hyphen
        value=$(_trim_space "${line}")
        value=$(_trim_hyphen "${line}")
        prefix="- "
      fi
    else
      type="other"
      value="${line}"
    fi

    # populate the associative array
    line_struct=(
      [type]="${type}"
      [level]="${level}"
      [line_number]="${line_number}"
      [key]="${key-}"
      [value]="${value-}"
      [prefix]="${prefix-}"
      [suffix]="${suffix-}"
    )

    # send the reference
    _manage line_struct

  done <<< "${yaml}"

  # Reset IFS to default value
  unset IFS
}

########################################
# Manage lines structures depending on action
# Attributes:
#   $1 # an associative array reference
########################################
_manage(){
  local -n line_manage="$1"

  # if a sequence and not being retrieved
  if [[ "${yb_is_sequence}" == true && "${yb_retrieve}" == false ]]; then
    # if sequence hasn't been found yet
    if [[ "${yb_is_retrieved}" == false ]]; then
      if [[ "${line_manage["key"]}" == "${yb_key["${yb_key_step}"]}" ]]; then
        # if sequence is found
        ((yb_key_step += 1))
        # if value is on a sub level, retrieve it
        if [[ "${yb_key_step}" -eq "${yb_key_length}" ]]; then
          yb_retrieve=true
          yb_key_base_level="${line_manage["level"]}"
          # if value is *key:value, retrieve only once
          if [[ "${line_manage["type"]}" == *"key:value" ]]; then
            _format line_manage
            # sequence is over, reset flags
            yb_key_step=0
            yb_is_retrieved=false
            yb_retrieve=false
          fi
        fi
      fi
    fi
  elif [[  "${yb_is_sequence}" == true && "${yb_retrieve}" == true ]]; then
    if [[ "${level}" -gt "${yb_key_base_level}"  ]]; then
      _format line_manage
    else 
      # if the level is lower or equal the key level
      # sequence is over, reset flags
      yb_key_step=0
      yb_is_retrieved=false
      yb_retrieve=false
    fi
  else
    # current parsing is not a selection
    _format line_manage
  fi
}

########################################
# Format structures depending on output
# Attributes:
#   $1 # an associative array reference
########################################
_format(){
  local -n line_format="${1-}"
  local level=${line_format["level"]}
  local type="${line_format["type"]}"
  local key="${line_format["key"]}"
  local value="${line_format["value"]}"
  local prefix="${line_format["prefix"]}"
  local suffix="${line_format["suffix"]}"
  local line_number="${line_format["line_number"]}"
  local line_spacer="{{line}}"
  local line_number_spacer="{{${line_number}}}"
  local spacer=""
  local outer=""

  if [[ "${yb_format}" == true ]]; then
    # if a sequence, substract base indentation
    if [[ ${yb_is_sequence} == true ]]; then
      local base_level="${yb_key_base_level-}"
      level=$(( $level - $base_level ))
    fi    
    # add a spacer '.' for each key line
    if [[ "${type}" == *"key"* ]]; then
      for (( i = 0; i < $(( $level + 1 )); i++ )); do
        spacer+="."
      done
    fi    
    # add an outer {{line}} for each line
    if [[ "${yb_show_line}" == true ]]; then
      outer+="${line_spacer}"
    fi    
    # add an outer {{$line_number}} for each line
    if [[ "${yb_show_line_number}" == true ]]; then
      outer+="${line_number_spacer}"
    fi
    if [[ "${yb_is_array}" == true ]]; then
      if [[ "${type}" != "comment" && "${type}" != "empty" ]]; then
        if [[ "${type}" == *"key:value" ]]; then
          yb_array+=("${spacer}${key} ${value}${outer}")
        else
          yb_array+=("${spacer}${key}${value}${outer}")
        fi
      fi
    else
      echo "${spacer}${prefix}${key}${suffix}${value}"
    fi
  else
    _print line_format
  fi
}

########################################
# Print to terminal
# Attributes:
#   $1 # an associative array reference
########################################
_print(){
  local -n line_print="$1"

  local level=${line_print["level"]}
  local type="${line_print["type"]}"
  local key="${line_print["key"]}"
  local value="${line_print["value"]}"
  local prefix="${line_print["prefix"]}"
  local suffix="${line_print["suffix"]}"
  local line_number="${line_print["line_number"]}"
  local line_spacer="{{line}}"
  local line_number_spacer="{{${line_number}}}"
  local spacer=""
  local string=""

  if [[ ${yb_is_raw} == true || ${yb_is_sequence} == false ]]; then
    level="${line_print["level"]}"
  else
    local base_level="${yb_key_base_level-}"
    local line_level=${line_print["level"]}
    level=$(( $line_level - $base_level - 1 ))
  fi

  for (( i = 0; i < "${level}"; i++ )); do
    spacer+="  "
  done

  # if '-R' is false, use colors
  if [[ "${yb_is_raw}" == false ]]; then
    if [[ "${type}" == "comment" ]]; then
        value=$(_to_color "${value}" "${yb_grey}")
    elif [[ "${line_print["type"]}" == *"key"* ]]; then
        key=$(_to_color "${key}" "${yb_blue}")
        prefix=$(_to_color "${prefix}" "${yb_blue}")
    fi
  fi

  if [[ "${type}" == "comment" ]]; then
    printf "${value-}\n"
  else
    string=$(echo -e "${spacer}${prefix}${key}${suffix}" && echo "${value}")
    echo "${spacer}"${string}
  fi
}

########################################
# Trim leading and trailing spaces
# Attributes:
#   $1 # string
########################################
_trim_space(){
  local string="${@-}"

  string=$(echo "$string" | sed -E 's/^ +//')
  string=$(echo "$string" | sed -E 's/ +$//')

  echo "${string}"
}

########################################
# Trim a leading hyphen and one space
# Attributes:
#   $1 # string
########################################
_trim_hyphen(){
  local string="${@-}"
  
  string="${string##*- }"

  echo "${string}"
}

########################################
# Add some color tags to a string
# Attributes:
#   $1 # string
#   $2 # an ANSI format color
########################################
_to_color(){
  local text="${1-}"
  local color="${2-}"

  echo "${color}${text}\033[0m"
}

########################################
# Prepare globals for sequence search
########################################
_sequence(){
  # set flags
  yb_is_sequence=true
  yb_retrieve=false

  # get selector key details
  yb_key=($(echo "${yb_key}" | tr -s '.' ' '))
  yb_key_length="${#yb_key[@]}"
}

########################################
# Parse script options
# Attributes:
#   $@ # getopts options
########################################
_parse_options(){
  local file="${yb_file-}"
  local key="${yb_key-}"

  if [[ -f ${file} ]]; then
    if [[ -n "${key}" ]]; then
      _sequence
    fi
  else
    echo "YAML file needs to be provided through the '-f' option."
    exit
  fi
}

########################################
# Initialize the cli
# Attributes:
#   $@ # script user options
########################################
_cli(){
  while getopts "Af:Fk:lnRv:s:" arg; do
    case $arg in
      A)
        yb_is_array=true
        ;;
      f)
        yb_file="${OPTARG}"
        ;;
      F)
        yb_format=true
        ;;
      k)
        yb_key="${OPTARG}"
        ;;
      l)
        yb_show_line=true
        ;;
      n)
        yb_show_line_number=true
        ;;
      R)
        yb_is_raw=true
        ;;
      v)
        yb_value="${OPTARG}"
        ;;
      s)
        yb_spacing="${OPTARG}"
        ;;
    esac
  done

  # if no options were provided
  if [[ "${OPTIND}" -eq 1 ]]; then
    # if arguments were provided
    if [[ "${#}" -gt 0 ]]; then
      yb_file="${1-}"
      yb_key="${2-}"
    else
      echo "No parameters provided"
      exit
    fi
  fi
}

########################################
# Main function
# Attributes:
#   $@ # script user options
########################################
main(){
  _globals "${@}"
  _cli "${@}"
  _parse_options "${@}"
  _parse_yaml "${yb_file}"

  if [[ "${yb_is_array}" == true ]]; then
    echo "${yb_array[@]}"
  fi
}

# Launch main function
main "${@}"

# Unsetting the eu flag
set +eu