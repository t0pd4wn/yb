#!/bin/bash
#---------------------------------------
# yb | yaml bash parser
#---------------------------------------

# Setting the eu flag
set -eu


########################################
# Declare globals
# Attributes:
#   $@ # script user options
########################################
_globals(){
  declare -g yb_spacing=2
  declare -g yb_grey="\033[0;30m"
  declare -g yb_blue="\033[1;36m"
  declare -g yb_orange="\033[1;33m"
  declare -g yb_format=false
  declare -g yb_is_array=false
  declare -g yb_is_raw=false
  declare -ga yb_array
  # declare -A yb_line
  declare -g yb_file_line_number
  declare -g yb_is_sequence=false
  declare -g yb_key_length=0
  declare -g yb_key_step=0
  declare -g yb_key_base_level
  declare -g yb_retrieve
  declare -g yb_is_retrieved=false
}

########################################
# Parse a yaml file
# Attributes:
#   $1 # /path/to/a/yaml/file 
########################################
_parse_yaml() {
  local file="${1-}"
  local bold_colon="$(_to_color ":" "\033[1m")"
  local hyphen="$(_to_color "-" "\033[1m")"
  local comment
  local yaml
  local separator
  local line
  local spaces
  local level
  local type
  local key
  local option_color=true
  local line_number=0

  # global associative array
  declare -A line_struct

  # Read the YAML file
  yaml=$(<"${file}")

  # Set whitespace as field separator
  IFS=$' \t\n'

  # Loop through each line of the YAML file
  while IFS= read -r line; do
    # keep track of current line number
    ((line_number += 1))

    # Count the leading spaces to determine the indentation level
    spaces="${line%%[^[:space:]]*}"
    level="${#spaces}"
    level="$(( level / yb_spacing ))"

    # Remove the leading and trailing spaces
    line=$(_trim_space "${line}")

    # Check the line type
    if [[ -z "${line}" ]]; then 
      type="empty"
    elif [[ "${line}" == "#"* ]]; then
      type="comment"
      value="${line}"
    elif [[ "${line}" == *":" && $line != *:*:* ]]; then
      type="key"
      key="${line%%:*}"
    elif [[ "${line}" == *": "* && ${line} != "- "* ]]; then
      type="key:value"
      # echo "key-value"
      key="${line%%:*}"
      value="${line#*:}"
      key=$(_trim_space $key)
      value=$(_trim_space $value)
    elif [[ "${line}" == "- "*": "* ]]; then
        type="list-key:value"
        key=$(_trim_space "${line}")
        key=$(_trim_hyphen "${key}")
        key="${key%%:*}"
        value="${line#*:}"
        value=$(_trim_space "${value}")
    elif [[ "${line}" == "- "* ]]; then
      if [[ ${level} -eq 0 ]]; then
        type="list-key"
        # Trim leading space and list hyphen
        key=$(_trim_space "${line}")
        key=$(_trim_hyphen "${line}")
      else
        type="list-value"
        # Trim leading space and list hyphen
        value=$(_trim_space "${line}")
        value=$(_trim_hyphen "${line}")
      fi
    else
      type="other"
      value="${line}"
    fi

    # populate the associative array
    line_struct=(
      [type]="${type}"
      [level]="${level}"
      [line_number]="${line_number}"
      [key]="${key-}"
      [value]="${value-}"
    )

    # send the reference
    _manage line_struct

  done <<< "${yaml}"

  # Reset IFS to default value
  unset IFS
}

########################################
# Manage lines structures depending on action
# Attributes:
#   $1 # an associative array reference
########################################
_manage(){
  local -n line="$1"
  # if a sequence and not being retrieved
  if [[ "${yb_is_sequence}" == true && "${yb_retrieve}" == false ]]; then
    # if sequence hasn't been found yet
    if [[ "${yb_is_retrieved}" == false ]]; then
      if [[ "${line["key"]}" == "${yb_key["${yb_key_step}"]}" ]]; then
        ((yb_key_step += 1))
        # if value is on a sub level, retrieve it
        if [[ "${yb_key_step}" -eq "${yb_key_length}" ]]; then
          yb_retrieve=true
          yb_key_base_level="${line["level"]}"
          # if value is key:value, retrieve only once
          if [[ "${line["type"]}" == "key:value" ]]; then
            _format line
            # sequence is over, reset flags
            yb_key_step=0
            yb_is_retrieved=false
            yb_retrieve=false
          fi
        fi
      fi
    fi
  elif [[  "${yb_is_sequence}" == true && "${yb_retrieve}" == true ]]; then
    if [[ "${level}" -gt "${yb_key_base_level}"  ]]; then
      _format line
    else 
      # if the level is lower or equal the key level
      # sequence is over, reset flags
      yb_key_step=0
      yb_is_retrieved=false
      yb_retrieve=false
    fi
  else
    # current parsing is not a selection
    _format line
  fi
}

########################################
# Format structures depending on output
# Attributes:
#   $1 # an associative array reference
########################################
_format(){
  local -n line_prepare="$1"
  local level=${line_prepare["level"]}
  local spacer=""

  if [[ ${yb_is_sequence} == true ]]; then
    local base_level="${yb_key_base_level-}"
    level=$(( $level - $base_level ))
  fi

  if [[ "${yb_format}" == true ]]; then

    for (( i = 0; i < ${level}; i++ )); do
      spacer+="."
    done

    if [[ "${line_prepare["type"]}" == "key" ]]; then
      if [[ "${yb_is_array}" == true ]]; then
        yb_array+=("${spacer}${line_prepare["key"]}")
      else
        echo "${spacer}${line_prepare["key"]}:"
      fi
    elif [[ "${line_prepare["type"]}" == "key:value" ]]; then
      if [[ "${yb_is_array}" == true ]]; then
        yb_array+=("${spacer}${line_prepare["key"]}")
        yb_array+=("${line_prepare["value"]}")
      else
        echo "${spacer}${line_prepare["key"]}: ${line_prepare["value"]}"
      fi
    elif [[ "${line_prepare["type"]}" == "list-key:value" ]]; then
      if [[ "${yb_is_array}" == true ]]; then
        yb_array+=("${spacer}${line_prepare["key"]}")
        yb_array+=("${line_prepare["value"]}")
      else
        echo "- ${line_prepare["key"]}: ${line_prepare["value"]}"
      fi
    elif [[ "${line_prepare["type"]}" == "list-value" ]]; then
      if [[ "${yb_is_array}" == true ]]; then
        yb_array+=("${line_prepare["value"]}")
      else
        echo "- ${line_prepare["value"]} "
      fi
    elif [[ "${line_prepare["type"]}" == "list-key" ]]; then
      if [[ "${yb_is_array}" == true ]]; then
        yb_array+=("${line_prepare["key"]}")
      else
        echo "- ${line_prepare["key"]} "
      fi
    fi
  else
    _print line_prepare
  fi
}

########################################
# Print to terminal
# Attributes:
#   $1 # an associative array reference
########################################
_print(){
  local -n line_print="$1"
  local spacer=""
  local level
  local key
  local value
  local hyphen

  if [[ ${yb_is_raw} == true || ${yb_is_sequence} == false ]]; then
    level="${line_print["level"]}"
  else
    local base_level="${yb_key_base_level-}"
    local line_level=${line_print["level"]}
    level=$(( $line_level - $base_level - 1 ))
  fi

  for (( i = 0; i < "${level}"; i++ )); do
    spacer+="  "
  done

  if [[ "${line_print["type"]}" == "empty" ]]; then
    if [[ ${yb_is_raw} == true ]]; then
      echo "${spacer}"
    else
      echo "${spacer}"
    fi
  elif [[ "${line_print["type"]}" == "comment" ]]; then
    if [[ ${yb_is_raw} == true ]]; then
      echo "${spacer}${line_print["value"]}"
    else
      value=$(_to_color "${line_print["value"]}" "${yb_grey}")
      echo -e "${spacer}${value}"
    fi
  elif [[ "${line_print["type"]}" == "key" ]]; then
    if [[ ${yb_is_raw} == true ]]; then
      echo "${spacer}${line_print["key"]}:"
    else
      key=$(_to_color "${line_print["key"]}" "${yb_blue}")
      echo -e "${spacer}${key}:"
    fi
  elif [[ "${line_print["type"]}" == "key:value" ]]; then
    if [[ ${yb_is_raw} == true ]]; then
      echo "${spacer}${line_print["key"]}: ${line_print["value"]}"
    else
      key=$(_to_color "${line_print["key"]}" "${yb_blue}")
      echo -e "${spacer}${key}: ${line_print["value"]}"
    fi
  elif [[ "${line_print["type"]}" == "list-value" ]]; then
    if [[ ${yb_is_raw} == true ]]; then
      echo "${spacer}- ${line_print["value"]}"
    else
      hyphen=$(_to_color "-" "${yb_blue}")
      echo -e "${spacer}${hyphen} ${line_print["value"]}"
    fi
  elif [[ "${line_print["type"]}" == "list-key" ]]; then
    if [[ ${yb_is_raw} == true ]]; then
      echo "${spacer}- ${line_print["key"]}"
    else
      key=$(_to_color "- ${line_print['key']}" "${yb_blue}")
      echo -e "${spacer}${key}"
    fi
  elif [[ "${line_print["type"]}" == "list-key:value" ]]; then
    if [[ ${yb_is_raw} == true ]]; then
      echo "${spacer}- ${line_print["key"]}: ${line_print["value"]}"
    else
      key=$(_to_color "- ${line_print['key']}" "${yb_blue}")
      echo -e "${spacer}${key}: ${line_print['value']}"
    fi
  fi
}

########################################
# Trim leading and trailing spaces
# Attributes:
#   $1 # string
########################################
_trim_space(){
  local string="${@-}"

  string=$(echo "$string" | sed -E 's/^ +//')
  string=$(echo "$string" | sed -E 's/ +$//')

  echo "${string}"
}

########################################
# Trim a leading hyphen and one space
# Attributes:
#   $1 # string
########################################
_trim_hyphen(){
  local string="${@-}"
  string="${string##*- }"

  echo "${string}"
}

########################################
# Add some color tags to a string
# Attributes:
#   $1 # string
#   $2 # an ANSI format color
########################################
_to_color(){
  local text="${1-}"
  local color="${2-}"

  echo "${color}${text}\033[0m"
}

########################################
# Prepare globals for sequence search
########################################
_sequence(){
  # set flags
  yb_is_sequence=true
  yb_retrieve=false

  # get selector key details
  yb_key=($(echo "${yb_key}" | tr -s '.' ' '))
  yb_key_length="${#yb_key[@]}"
}

########################################
# Parse script options
# Attributes:
#   $@ # getopts options
########################################
_parse_options(){
  local file="${yb_file}"
  local key="${yb_key-}"

  if [[ -n "${key}" ]]; then
    _sequence
  fi
}

########################################
# Initialize the cli
# Attributes:
#   $@ # script user options
########################################
_cli(){
  while getopts "Af:Fk:Rv:s:" arg; do
    case $arg in
      A)
        yb_is_array=true
        ;;
      f)
        yb_file="${OPTARG}"
        ;;
      F)
        yb_format=true
        ;;
      k)
        yb_key="${OPTARG}"
        ;;
      R)
        yb_is_raw=true
        ;;
      v)
        yb_value="${OPTARG}"
        ;;
      s)
        yb_spacing="${OPTARG}"
        ;;
    esac
  done

  # if no options were provided
  if [[ "${OPTIND}" -eq 1 ]]; then
    # if arguments were provided
    if [[ "${#}" -gt 0 ]]; then
      yb_file="${1-}"
      yb_key="${2-}"
    else
      echo "No parameters provided"
      exit
    fi
  fi
}

########################################
# Main function
# Attributes:
#   $@ # script user options
########################################
main(){
  _globals "${@}"
  _cli "${@}"
  _parse_options "${@}"
  _parse_yaml "${yb_file}"

  if [[ "${yb_is_array}" == true ]]; then
    echo "${yb_array[@]}"
  fi
}

# Launch main function
main "${@}"

# Unsetting the eu flag
set +eu